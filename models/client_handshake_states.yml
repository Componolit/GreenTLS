# supported extensions: server_name, max_fragment_length, supported_groups, signature_algorithms, use_srtp, heartbeat, application_layer_protocol_negotiation, client_certificate_type, server_certificate_type, padding, key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, post_handshake_auth, signature_algorithms_cert
# unsupported: signed_certificate_timestamp, status_request
# FIXME: "A peer which receives a handshake message in an unexpected order MUST abort the handshake with an "UNEXPECTED_Message" alert."
# FIXME: "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake."
# FIXME: It must be ensured that each extension type only exists once in an extension list.
# FIXME: Configuration component -> ROM
initial: START
final: FINAL
channels:
  - name: Record_Data_Channel
    type: TLS_Handshake.TLS_Handshake
    mode: Read_Write
  - name: Record_Control_Channel
    type: GreenTLS.Control_Message
    mode: Write
  - name: RNG_Channel
    type: Stream
    mode: Read
  - name: Keystore_Channel
    type: GreenTLS.Keystore_Message
    mode: Read_Write
  - name: Application_Control_Channel
    type: GreenTLS.Application_Control_Message
    mode: Read_Write
  - name: Configuration_Channel
    type: GreenTLS.Configuration
    mode: Read
  - name: Connection_Channel
    type: GreenTLS.Connection
    mode: Read
types:
  - "Hash_Context is private"
variables:
  - "Application_Layer_Protocol_Negotiation_Received : Boolean := False"
  - "Binders : TLS_Handshake.PSK_Binder_Entries := Initialize (4096 * 8)"
  - "CCR_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "CH_Cookie_Prepared : Boolean := False"
  - "CH_Key_Share_Prepared : Boolean := False"
  - "CH_PSK_Prepared : Boolean := False"
  - "Certificate_Authorities : TLS_Handshake.Distinguished_Names := Initialize (4096 * 8)"
  - "Certificate_Authorities_Received : Boolean := False"
  - "Certificate_Request_Received : Boolean := False"
  - "Client_Handshake_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Client_Hello_1_Hash : Hash_Context"
  - "Client_Hello_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Client_Shares : TLS_Handshake.Key_Share_Entries := Initialize (4096 * 8)"
  - "Connection : GreenTLS.Connection := Initialize (4096 * 8)"
  - "DHE_Accepted : Boolean := False"
  - "Derived_Handshake_Secret : GreenTLS.Content := Initialize (512)"
  - "Early_Data_Received : Boolean := False"
  - "Early_Secret : GreenTLS.Content := Initialize (512)"
  - "Encrypted_Extensions_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Extensions_List : TLS_Handshake.Extensions := Initialize (4096 * 8)"
  - "Hash_Length : GreenTLS.KM_Length"
  - "Heartbeat_Received : Boolean := False"
  - "Identity_Index : TLS_Handshake.Identity_Index"
  - "Keystore_Message : GreenTLS.Keystore_Message := Initialize (192)"
  - "Max_Fragment_Length : TLS_Handshake.Max_Fragment_Length_Value"
  - "Max_Fragment_Length_Received : Boolean := False"
  - "OID_Filters : TLS_Handshake.Filters := Initialize (4096 * 8)"
  - "OID_Filters_Received : Boolean := False"
  - "PSKs : GreenTLS.PSKs := Initialize (4096 * 8)"
  - "Pre_Shared_Key_CH : TLS_Handshake.Pre_Shared_Key_CH := Initialize (4096 * 8)"
  - "Retry_Request_Received : Boolean := False"
  - "Selected_Group : TLS_Handshake.Named_Group"
  - "Server_Handshake_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Server_Hello_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Server_Name_Extension : TLS_Handshake.Extension := Initialize (4096 * 8)"
  - "Server_Name_Received : Boolean := False"
  - "Server_Preferred_Groups : TLS_Handshake.Supported_Groups := Initialize (176)"
  - "Signature_Algorithms : TLS_Handshake.Signature_Schemes := Initialize (4096 * 8)"
  - "Signature_Algorithms_Cert : TLS_Handshake.Signature_Schemes := Initialize (4096 * 8)"
  - "Signature_Algorithms_Cert_Received : Boolean := False"
  - "Signature_Algorithms_Received : Boolean := False"
  - "Success : Boolean"
  - "Supported_Groups : TLS_Handshake.Named_Groups := Initialize (160)"
  - "Supported_Groups_Received : Boolean := False"
  - "Transcript_Hash : Hash_Context"
renames:
  - "Certificate_Message : TLS_Handshake.Certificate renames CCR_Handshake_Message.Payload"
  - "Certificate_Request_Message : TLS_Handshake.Certificate_Request renames CCR_Handshake_Message.Payload"
  - "Client_Hello_Message : TLS_Handshake.Client_Hello renames Client_Hello_Handshake_Message.Payload"
  - "Encrypted_Extensions_Message : TLS_Handshake.Encrypted_Extensions renames Encrypted_Extensions_Handshake_Message.Payload"
  - "Server_Hello_Message : TLS_Handshake.Server_Hello renames Server_Hello_Handshake_Message.Payload"
functions:
  - "Calculate_Binders (PSKs : GreenTLS.PSKs; Transcript_Hash : GreenTLS.Content) return TLS_Handshake.PSK_Binder_Entries"
  - "Calculate_Binders_Length (PSKs : GreenTLS.PSKs) return RFLX.Types.Bit_Length"
  - "Calculate_ECDHE_Key (Client_Share : TLS_Handshake.Key_Share_Entry; Server_Share : TLS_Handshake.Key_Share_Entry) return GreenTLS.Content"
  - "Derive_Secret (Secret : GreenTLS.Content; Label : String; Transcript_Hash : GreenTLS.Content) return GreenTLS.Content"
  - "Empty_Hash return Hash_Context"
  - "Get_Hash (Context : Hash_Context) return GreenTLS.Content"
  - "HKDF_Expand_Label (Secret : GreenTLS.Content; Label : String; Context : GreenTLS.Content; Length : GreenTLS.KM_Length) return GreenTLS.Content"
  - "HKDF_Extract (Salt : GreenTLS.Content; IKM : GreenTLS.Content) return GreenTLS.Content"
  - "Hash_Length (Cipher_Suite : TLS_Handshake.Cipher_Suite) return GreenTLS.KM_Length"
  - "Select_Supported_Groups (Server_Preferred_Groups : TLS_Handshake.Named_Groups; Supported_Groups : TLS_Handshake.Named_Groups) return TLS_Handshake.Named_Groups"
  - "Truncate_Client_Hello (Client_Hello : TLS_Handshake.Handshake) return GreenTLS.Content"
  - "Update_Hash (Context : Hash_Context; Data : Payload) return Hash_Context"
states:
  - name: START
    actions:
      - Connection := Read (Connection_Channel)
      - Configuration := Read (Configuration_Channel)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Connection'Valid = False
      - target: ERROR.INTERNAL_ERROR
        condition: Configuration'Valid = False
      - target: SERVER_PREFERRED_GROUPS

  - name: SERVER_PREFERRED_GROUPS
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message (Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS
      - target: SERVER_PREFERRED_GROUPS.CONFIGURE

  - name: SERVER_PREFERRED_GROUPS.CONFIGURE
    actions:
      - Server_Preferred_Groups := TLS_Handshake.Supported_Groups (Keystore_Message.Payload);
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Server_Preferred_Groups'Valid = False
      - target: SERVER_PREFERRED_GROUPS.SELECT

  - name: SERVER_PREFERRED_GROUPS.SELECT
    actions:
      - Supported_Groups := Select_Supported_Groups (Server_Preferred_Groups.Supported_Groups, Configuration.Supported_Groups)
    transitions:
      - target: CREATE_CLIENT_HELLO_EXTENSIONS

  - name: CREATE_CLIENT_HELLO_EXTENSIONS
    variables:
      - "Supported_Version : TLS_Handshake.Supported_Version := Initialize (16)"
      - "Supported_Versions_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
    actions:
      - Supported_Version := TLS_Handshake.Supported_Version'(Version => TLS_Handshake.TLS_1_3)
      - Supported_Versions_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS, Data_Length => Supported_Version'Length, Data => Supported_Version)
      - Extensions_List'Append (Supported_Versions_Extension)
      - Extensions_List'Extend (Create_Client_Hello_Extensions (Configuration))  # FIXME: define function
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.POST_HANDSHAKE_AUTH_EXTENSION
        condition: Configuration.Post_Handshake_Auth_Enabled = True
      - target: START.DHE
        condition: TLS_Handshake.PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: ERROR.INTERNAL_ERROR

  - name: START.POST_HANDSHAKE_AUTH_EXTENSION
    variables:
      - "Post_Handshake_Auth_Extension : TLS_Handshake.CH_Extension := Initialize (32)"
    actions:
      - Post_Handshake_Auth_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_POST_HANDSHAKE_AUTH, Data_Length => 0)
      - Extensions_List'Append (Post_Handshake_Auth_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.DHE
        condition: TLS_Handshake.PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: ERROR.INTERNAL_ERROR

  - name: START.DHE
    variables:
      - "Supported_Groups_Extension : TLS_Handshake.CH_Extension := Initialize (208)"
      - "Key_Share_Extension : TLS_Handshake.CH_Extension := Initialize (4096 * 8)"
      - "Signature_Algorithms_Extension : TLS_Handshake.CH_Extension := Initialize (320)"
    actions:
      - Supported_Groups_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SUPPORTED_GROUPS, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Supported_Groups'(Length => Configuration.Supported_Groups_Length, Groups => Configuration.Supported_Groups)
      - Extensions_List'Append (Supported_Groups_Extension)
      - Key_Share_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_KEY_SHARE, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Key_Share'(Length => Configuration.Key_Shares_Length, Shares => Configuration.Key_Shares)
      - Extensions_List'Append (Key_Share_Extension)
      - Signature_Algorithms_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Signature_Algorithms'(Length => Configuration.Signature_Algorithms_Length, Algorithms => Configuration.Signature_Algorithms)
      - Extensions_List'Append (Signature_Algorithms_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.DHE_SIGNATURE_ALGORITHMS
        condition: Configuration.Server_Authentication_Enabled = True
        doc: rfc8446.txt+2259:43-2261:36
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.SEND

  - name: START.DHE_SIGNATURE_ALGORITHMS
    variables:
      - "Signature_Algorithms_Cert_Extension : TLS_Handshake.CH_Extension := Initialize (320)"
    actions:
      - Signature_Algorithms_Cert_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Signature_Algorithms_Cert'(Length => Configuration.Signature_Algorithms_Cert_Length, Algorithms => Configuration.Signature_Algorithms_Cert)
      - Extensions_List'Append (Signature_Algorithms_Cert_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.SEND

  - name: START.PSK
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSK_IDENTITIES or (Keystore_Message.Length = 0 and TLS_Handshake.PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes)
      - target: START.SEND
        condition: Keystore_Message.Length = 0
      - target: START.PSK_EXTENSION_CHECK

  - name: START.PSK_EXTENSION_CHECK
    variables:
      - "PSK_Identities : TLS_Handshake.PSK_Identities := Initialize (4096 * 8)"
    actions:
      - PSKs := GreenTLS.PSK_Message (Keystore_Message.Payload).PSKs
      - Binders_Length := Calculate_Binders_Length (PSKs)
      - PSK_Identities := [for K in PSKs => K.Identity]
      - Pre_Shared_Key_CH := TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => null)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Pre_Shared_Key_CH'Valid = False
      - target: START.PSK_EXTENSIONS

  - name: START.PSK_EXTENSIONS
    variables:
      - "PSK_Key_Exchange_Modes_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
      - "Client_Hello_Hash : Hash_Context"
    actions:
      - PSK_Key_Exchange_Modes_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes)
      - Extensions_List'Append (PSK_Key_Exchange_Modes_Extension)
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Client_Hello_Hash := Empty_Hash
      - Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Payload)
      - Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash))
      - Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY]
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH) where PSK_CH = TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => Binders)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.SEND

  - name: START.SEND
    variables:
      - "Random : GreenTLS.Content := Initialize (32 * 8)"
    actions:
      - Random := Read (RNG_Channel)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message)
      - Client_Hello_1_Hash := Empty_Hash
      - Client_Hello_1_Hash := Update_Hash (Client_Hello_1_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Payload)
      - Transcript_Hash := Empty_Hash
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Payload)
      - Client_Hello_Message := Handshake.Client_Hello (Client_Hello_Handshake_Message.Payload)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: START.SEND_CLIENT_EARLY_TRAFFIC_SECRET
        condition: Configuration.Early_Data_Enabled = True
      - target: WAIT_SH

  - name: START.SEND_CLIENT_EARLY_TRAFFIC_SECRET
    variables:
      - "Client_Early_Traffic_Secret : GreenTLS.Content := Initialize (512)"
      - "Client_Write_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Write_IV : GreenTLS.Content := Initialize (512)"
    actions:
      - Early_Secret := HKDF_Extract (0, GreenTLS.Content (Data => PSKs (0).Key))
      - Client_Early_Traffic_Secret := Derive_Secret (Early_Secret.Data, "c e traffic", Get_Hash (Transcript_Hash))
      - Client_Write_Key := HKDF_Expand_Label (Client_Early_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Write_IV := HKDF_Expand_Label (Client_Early_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Delete (Keystore_Message)
      - Success := Write (Record_Data_Channel, GreenTLS.Control_Message (Tag => KEY_UDPATE_CLIENT, Length => KU'Length, Payload => KU) where KU = GreenTLS.Key_Update_Message'(Key_Length => Client_Write_Key'Length, Key => Client_Write_Key.Data, IV_Length => Client_Write_IV'Length, IV => Client_Write_IV.Data))
    doc: rfc8446.txt+2938:43-2940:30
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_SH

  - name: WAIT_SH
    actions:
      - Server_Hello_Handshake_Message := Read (Record_Data_Channel)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Server_Hello_Handshake_Message'Payload)
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: Server_Hello_Handshake_Message'Valid = False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: Server_Hello_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_SERVER_HELLO
      - target: SEND_ALERT_DECODE_ERROR
        condition: Server_Hello_Message'Valid = False
      - target: SEND_ALERT_PROTOCOL_VERSION
        condition: Server_Hello_Message.Legacy_Version /= GreenTLS.TLS_1_2
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Server_Hello_Message.Legacy_Session_Id_Echo /= 0 or Server_Hello_Message.Legacy_Compression_Method /= 0
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Server_Hello_Message.Cipher_Suite not in Client_Hello_Message.Cipher_Suites
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: for all E in Server_Hello_Message.Extensions => E.Tag /= TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Server_Hello_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS and not (GreenTLS.TLS_1_3 in TLS_Handshake.Supported_Versions (E.Data).Versions))
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Server_Hello_Message.Extensions => not E in Client_Hello_Message.Extensions
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes and (for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE)
        doc: rfc8446.txt+2770:46-2771:59
      - target: WAIT_SH.PARSE_HRR
        condition: Server_Hello_Message.HRR_Extensions'Present and Retry_Request_Received = False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: not Server_Hello_Message.HRR_Extensions'Present and Retry_Request_Received = True
      - target: WAIT_SH.EXTENSIONS_PSK
        condition: for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY
        doc: rfc8446.txt+643:57-646:21
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
        doc: rfc8446.txt+640:45-642:47
      - target: INVALID_CONFIGURATION

  - name: WAIT_SH.EXTENSIONS_PSK
    actions:
      - Identity_Index := TLS_Handshake.Pre_Shared_Key_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY]\'Head.Data).Selected_Identity
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Identity_Index /= 0 and (for any E in Server_Hello_Message.Extensions => E.Tag = EXTENSION_EARLY_DATA)
        doc: rfc8446.txt+3199:4-3202:29
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Client_Hello_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY and TLS_Handshake.Pre_Shared_Key_CH (E.Data).Identities'Length < Identity_Index)
      - target: WAIT_SH.EXTENSIONS_PSK_REQUEST

  - name: WAIT_SH.EXTENSIONS_PSK_REQUEST
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message (Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSK, Length => Selected_Identity'Length, Payload => Selected_Identity) where Selected_Identity = TLS_Handshake.Pre_Shared_Key_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY]\'Head.Data).Identities (Identity_Index))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSK or GreenTLS.PSK (Keystore_Message.Payload)'Valid = False
      - target: WAIT_SH.EXTENSIONS_PSK_VALIDATION

  - name: WAIT_SH.EXTENSIONS_PSK_VALIDATION
    variables:
      - "Identity_Cipher_Suite : TLS_Handshake.Cipher_Suite"
    actions:
      - Identity_Cipher_Suite := GreenTLS.PSK (Keystore_Message.Payload).Cipher_Suite
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Identity_Cipher_Suite /= Server_Hello_Message.Cipher_Suite
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
        doc:
          - rfc8446.txt+2765:4-2766:36
          - rfc8446.txt+646:24-647:60
      - target: SET_RECORD_KEYS

  - name: WAIT_SH.EXTENSIONS_DHE
    actions:
      - Selected_Group := TLS_Handshake.Key_Share_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]\'Head.Data).Group
      - DHE_Accepted := True
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: not (for any S in TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]\'Head.Data).Shares => S.Group = Selected_Group)
        doc: rfc8446.txt+2766:39-2768:55
      - target: SET_RECORD_KEYS

  - name: WAIT_SH.PARSE_HRR
    variables:
      - "Client_Supported_Groups : TLS_Handshake.Named_Groups := Initialize (160)"
    actions:
      - Retry_Request_Received := True
      - Client_Supported_Groups := TLS_Handshake.Supported_Groups ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS]\'Head.Data).Groups
      - Client_Shares := TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]\'Head.Data).Shares
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Server_Hello_Message.Extensions => E not in Client_Hello_Message.Extensions and E.Tag /= TLS_Handshake.EXTENSION_COOKIE
        doc: rfc8446.txt+1825:70-1829:28
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE and not (TLS_Handshake.Key_Share_HRR (E.Data).Selected_Group in Client_Supported_Groups)
        doc: rfc8446.txt+2736:21-2738:23
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE and (for any S in Client_Shares => S.Group = TLS_Handshake.Key_Share_HRR (E.Data).Selected_Group)
        doc: rfc8446.txt+2738:29-2740:31
      - target: WAIT_SH.PREPARE_CH

  - name: WAIT_SH.PREPARE_CH
    actions:
      - Extensions_List'Reset
      - Extensions_List'Extend ([for E in Client_Hello_Message.Extensions => E when E.Tag /= TLS_Handshake.EXTENSION_KEY_SHARE and E.Tag /= TLS_Handshake.EXTENSION_EARLY_DATA and E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY])
    doc: rfc8446.txt+1497:7-1498:70
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_DISPATCH
    actions:
    transitions:
      - target: WAIT_SH.PREPARE_CH_KEY_SHARE
        condition: CH_Key_Share_Prepared = False and for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
      - target: WAIT_SH.PREPARE_CH_COOKIE
        condition: CH_Cookie_Prepared = False and for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_COOKIE
      - target: WAIT_SH.PREPARE_CH_PSK
        condition: CH_PSK_Prepared = False and for any E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY
      - target: WAIT_SH.SEND_CH

  - name: WAIT_SH.PREPARE_CH_KEY_SHARE
    actions:
      - Extensions_List'Append (TLS_Handshake.Extension'(Tag => EXTENSION_KEY_SHARE, Data_Length => Key_Share'Length, Data => Key_Share)) where Key_Share = TLS_Handshake.Key_Share_CH'(Length => Entries'Length, Shares => Entries) where Entries = [for E in Client_Shares => E when E.Group = Selected_Group]
      - CH_Key_Share_Prepared := True
    doc: rfc8446.txt+2742:12-2753:39
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_COOKIE
    actions:
      - Extensions_List'Append ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_COOKIE]\'Head)
      - CH_Cookie_Prepared := True
    doc: rfc8446.txt+2223:19-2225:47
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_PSK
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection))
    doc: rfc8446.txt+1519:7-1520:51
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSKS or (Keystore_Message.Length = 0 and TLS_Handshake.PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes) or GreenTLS.PSK_Message (Keystore_Message.Payload)'Valid = False
      - target: WAIT_SH.NO_PSK_EXTENSION
        condition: Keystore_Message.Length = 0
      - target: WAIT_SH.PSK_EXTENSION_CHECK

  - name: WAIT_SH.PSK_EXTENSION_CHECK
    variables:
      - "PSK_Identities : TLS_Handshake.PSK_Identities := Initialize (4096 * 8)"
    actions:
      - PSKs := [for K in GreenTLS.PSK_Message (Keystore_Message.Payload).PSKs => K when K.Cipher_Suite = Server_Hello.Cipher_Suite]
      - Binders_Length := Calculate_Binders_Length (PSKs)
      - PSK_Identities := [for K in PSKs => K.Identity]
      - Pre_Shared_Key_CH := TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => null)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Pre_Shared_Key_CH'Valid = False
      - target: WAIT_SH.PSK_EXTENSIONS

  - name: WAIT_SH.PSK_EXTENSIONS
    variables:
      - "PSK_Key_Exchange_Modes_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
      - "Client_Hello_Hash : Hash_Context"
    actions:
      - PSK_Key_Exchange_Modes_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes)
      - Extensions_List'Append (PSK_Key_Exchange_Modes_Extension)
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Client_Hello_Hash := Empty_Hash
      - Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Payload)
      - Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash))
      - Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY]
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH) where PSK_CH = TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => Binders)
      - CH_PSK_Prepared := True
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.NO_PSK_EXTENSION
    actions:
      - CH_PSK_Prepared := True
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.SEND_CH
    variables:
      - "Random : GreenTLS.Content := Initialize (32 * 8)"
      - "Transcript_Hash_2 : GreenTLS.Content := Initialize (512)"
    actions:
      - Transcript_Hash_2 := Empty_Hash
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, TLS_Handshake.Handshake'(Tag => HANDSHAKE_MESSAGE_HASH, Length => CH1_Hash'Length, Payload => CH1_Hash.Data)'Payload) where CH1_Hash := Get_Hash (Client_Hello_1_Hash)
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Server_Hello_Handshake_Message'Payload)
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Payload)
      - Random := Client_Hello_Message.Random
      - Client_Hello_Handshake_Message'Reset
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Payload)
    doc: rfc8446.txt+3264:4-3275:42
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_SH

  - name: SET_RECORD_KEYS
    variables:
      - "Derived_Early_Secret : GreenTLS.Content := Initialize (512)"
      - "Handshake_Secret : GreenTLS.Content := Initialize (512)"
    actions:
      - Derived_Early_Secret := Derive_Secret (Early_Secret, "derived", Get_Hash (Empty_Hash))
      - Early_Secret := null
      - Handshake_Secret := HKDF_Extract (Derived_Early_Secret, Key) where Key = Calculate_ECDHE_Key (Client_Share, TLS_Handshake.Key_Share_Entry ([for E in Server_Hello_Message.Extensions => E when E.Tag = EXTENSION_KEY_SHARE]\'Head).Data) where Client_Share = [for S in TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]\'Head.Data).Shares => S when S.Group = Selected_Group]\'Head
      - Derived_Early_Secret := null
      - Client_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "c hs traffic", Get_Hash (Transcript_Hash))
      - Server_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "s hs traffic", Get_Hash (Transcript_Hash))
      - Success := Write (Record_Control_Channel, GreenTLS.Record_Control_Message (Tag => SET_KEYS, Length => Data'Length, Data => Data) where Data = GreenTLS.Record_Keys'(Read_Key_Length => Server_Handshake_Traffic_Secret'Length, Read_Key => Server_Handshake_Traffic_Secret.Data, Write_Key_Length => Client_Handshake_Traffic_Secret'Length, Write_Key => Client_Handshake_Traffic_Secret.Data))
      - Server_Handshake_Traffic_Secret := null
      - Derived_Handshake_Secret := Derive_Secret (Handshake_Secret, "derived", Get_Hash (Empty_Hash))
      - Handshake_Secret := null
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_EE

  - name: WAIT_EE
    actions:
      - Encrypted_Extensions_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: Encrypted_Extensions_Handshake_Message'Valid = False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: Encrypted_Extensions_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_ENCRYPTED_EXTENSIONS
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PARSE_EXTENSIONS
    actions:
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_STATUS_REQUEST or E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS or E.Tag = TLS_Handshake.EXTENSION_SIGNED_CERTIFICATE_TIMESTAMP or E.Tag = TLS_Handshake.EXTENSION_PADDING or E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE or E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY or E.Tag = TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES or E.Tag = TLS_Handshake.EXTENSION_COOKIE or E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS or E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES or E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS or E.Tag = TLS_Handshake.EXTENSION_POST_HANDSHAKE_AUTH or E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT)
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Server_Name_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME)) and Configuration.Server_Name_Enabled = False
        doc: rfc6066.txt+376:46-378:16
      - target: WAIT_EE.PROCESS_SERVER_NAME
        condition: Server_Name_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME))
      - target: WAIT_EE.PROCESS_MAX_FRAGMENT_LENGTH
        condition: Max_Fragment_Length_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_MAX_FRAGMENT_LENGTH))
      - target: WAIT_EE.PROCESS_SUPPORTED_GROUPS
        condition: Supported_Groups_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS))
      - target: WAIT_EE.PROCESS_HEARTBEAT
        condition: Heartbeat_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_HEARTBEAT))
      - target: WAIT_EE.PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
        condition: Application_Layer_Protocol_Negotiation_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION))
      - target: WAIT_EE.PROCESS_EARLY_DATA
        condition: Early_Data_Received = False and (for any E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_EARLY_DATA))
      - target: WAIT_EE.CHECK_EXTENSIONS

  - name: WAIT_EE.PROCESS_SERVER_NAME
    actions:
      - Server_Name_Extension := [for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME]\'Head  # FIXME: never used yet
      - Server_Name_Received := True
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Server_Name_Extension.Data_Length > 0
        doc: rfc6066.txt+378:19-379:9
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_MAX_FRAGMENT_LENGTH
    actions:
      - Max_Fragment_Length := TLS_Handshake.Max_Fragment_Length ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_MAX_FRAGMENT_LENGTH]\'Head.Data).Max_Fragment_Length
      - Max_Fragment_Length_Received := True
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Configuration.Max_Fragment_Length /= Max_Fragment_Length
        doc: rfc6066.txt+435:50-438:32
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_SUPPORTED_GROUPS
    actions:
      - Server_Preferred_Groups := TLS_Handshake.Supported_Groups ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS]\'Head.Data).Groups  # FIXME: store after successful handshake
      - Supported_Groups_Received := True
    doc: rfc8446.txt+2651:4-2661:68
    transitions:
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_HEARTBEAT
    variables:
      - "Server_Heartbeat_Mode : TLS_Handshake.Heartbeat_Mode"
    actions:
      - Server_Heartbeat_Mode := TLS_Handshake.Heartbeat ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_HEARTBEAT]\'Head.Data).Mode
      - Success := Write (Record_Control_Channel, GreenTLS.Control_Message'(Tag => GreenTLS.HEARTBEAT_MODE, Length => Data'Length, Payload => Data) where Data = GreenTLS.Heartbeat_Control_Message'(Local => Configuration.Heartbeat_Mode, Remote => Server_Heartbeat_Mode))
      - Heartbeat_Received := True
    doc: rfc6520.txt+138:4-149:61
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
    variables:
      - "Protocols : TLS_Handshake.Protocol_Names := Initialize (4096 * 8)"
    actions:
      - Protocols := TLS_Handshake.Protocol_Name_List ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION]\'Head.Data).Protocol_Name_List
      - Success := Write (Application_Control_Channel, GreenTLS.Application_Control_Message'(GreenTLS.APPLICATION_PROTOCOL, Protocols'Head))
      - Application_Layer_Protocol_Negotiation_Received := True
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: Protocols'Length /= 1
        doc: rfc7301.txt+181:53-185:30
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: (for all P in Configuration.Protocols => P /= Protocols\'Head)
        doc: rfc7301.txt+175:4-177:54
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_EARLY_DATA
    actions:
      - Early_Data_Received := True
    doc: rfc8446.txt+2993:7-2998:45
    transitions:
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.CHECK_EXTENSIONS
    actions:
      - Transcript_Hash := Update_Hash (Transcript_Hash, Encrypted_Extensions_Message'Payload)
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: Configuration.Server_Name_Enabled = True and Server_Name_Received = False
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: Configuration.Max_Fragment_Length_Enabled = True and Max_Fragment_Length_Received = False
      - target: WAIT_EE.NO_EARLY_DATA
        condition: Configuration.Early_Data_Enabled = True and Early_Data_Received = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.NO_EARLY_DATA
    actions:
      - Success := Write (Application_Control_Channel, GreenTLS.Application_Control_Message'(Tag => APPLICATION_NO_EARLY_DATA, Length => Data'Length, Data => Data) where GreenTLS.Application_No_Early_Data_Message'(null message))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.DISPATCH
    actions:
    transitions:
      - target: WAIT_CERT_CR
        condition: DHE_Accepted = True
      - target: WAIT_FINISHED

  - name: WAIT_CERT_CR
    actions:
      - CCR_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: CCR_Handshake_Message'Valid = False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: CCR_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_CERTIFICATE and CCR_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_CERTIFICATE_REQUEST
      - target: PARSE_CERT
        condition: Certificate_Message'Valid = True
      - target: PARSE_CR
        condition: Certificate_Request_Message'Valid = True
      - target: SEND_ALERT_DECODE_ERROR

  - name: PARSE_CR
    actions:
      - Certificate_Request_Received := True
    transitions:
      - target: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: Certificate_Authorities_Received = False and (for any E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES))
      - target: PARSE_CR.PARSE_OID_FILTERS
        condition: OID_Filters_Received = False and (for any E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS))
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: Signature_Algorithms_Received = False and (for any E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS))
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: Signature_Algorithms_Cert_Received = False and (for any E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT))
      - target: PARSE_CR.CHECK_EXTENSIONS

  - name: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - Certificate_Authorities_Received := True
      - Certificate_Authorities := TLS_Handshake.Certificate_Authorities ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES]\'Head.Data).Authorities
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_OID_FILTERS
    actions:
      - OID_Filters_Received := True
      - OID_Filters := TLS_Handshake.OID_Filters ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS]\'Head.Data).Filters
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - Signature_Algorithms_Received := True
      - Signature_Algorithms := TLS_Handshake.Signature_Algorithms ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS]\'Head.Data).Algorithms
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for all A in Configuration.Signature_Algorithms => not A in Signature_Algorithms
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - Signature_Algorithms_Cert_Received := True
      - Signature_Algorithms_Cert := TLS_Handshake.Signature_Algorithms_Cert ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT]\'Head.Data).Algorithms
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: for all A in Configuration.Signature_Algorithms_Cert => not A in Signature_Algorithms_Cert
      - target: PARSE_CR

  - name: PARSE_CR.CHECK_EXTENSIONS
    actions:
      - Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Payload)
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: Signature_Algorithms_Received = False
      - target: WAIT_CERT

  - name: WAIT_CERT  # TODO: CONTINUE
    actions:
      - CCR_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: CCR_Message'Valid = False
      - target: PARSE_CERT
        condition: CCR_Message.Tag = TLS_Handshake.HANDSHAKE_CERTIFICATE
      - target: SEND_ALERT_DECODE_ERROR
        condition: TLS_Handshake.Certificate (CCR_Message.Payload).Certificate_List_Length = 0
        doc: rfc8446.txt+3649:4-3649:58
      - target: PARSE_CERT

  - name: PARSE_CERT
    actions:
      - Server_Certificate_Message := CCR_Message
      - Transcript_Hash := Update_Hash (Transcript_Hash, Server_Certificate_Message'Payload)
    transitions:
      - target: PARSE_CERT.PARSE_ENTRIES

  - name: PARSE_CERT.PARSE_ENTRIES
    actions:
      - Parse CertificateEntry from Server_Certificate_Message
      - Store CertificateEntry in CertificateList
      - Check next entry
    transitions:
      - target: PARSE_CERT.VERIFY_CERTIFICATE
        condition: no further entries
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.PARSE_EXTENSIONS
    actions:
      - Parse CertificateEntry.Extensions
      - Check next extensions, skip if unknown  # FIXME: Signed_Certificate_Timestamp not supported
    transitions:
      - target: PARSE_CERT.PARSE_STATUS_REQUEST
        condition: Status_Request extension found and was requested by Configuration.Status_Request
      - target: PARSE_CERT.PARSE_ENTRIES
        condition: no further extensions

  - name: PARSE_CERT.PARSE_STATUS_REQUEST
    actions:
      - Read and verify CertificateStatus from CertificateEntry.Extensions
    transitions:
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.VERIFY_CERTIFICATE
    actions:
      - Verify certificates and their status in CertificateList
    transitions:
      - target: WAIT_CV
        condition: certificate valid
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: invalid certificate
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: Certificate uses MD5 or is invalid

  - name: WAIT_CV
    actions:
      - Read CertificateVerify from Record_Data_Channel
      - Ensure CertificateVerify.Algorithm is one of Configuration.Signature_Algorithms
      - Ensure CertificateVerify.Algorithm is compatible to signature algorithm in Certificate
      - Ensure RSA signatures use an RSASSA-PSS algorithm
      - Ensure SHA-1 is not used
      - Verify CertificateVerify.Signature using Transcript_Hash and public key of Certificate using CertificateVerify.Algorithm
      - Transcript_Hash := Update_Hash (Transcript_Hash, CertificateVerify_Message'Payload)
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: other message than CertificateVerify received
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: invalid algorithm
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: signature invalid
      - target: WAIT_FINISHED

  - name: WAIT_FINISHED
    actions:
      - Hash_Length := Hash_Length (Server_Hello_Message.Cipher_Suite)
      - Read Finished from Record_Data_Channel
      - Finished_Key := HKDF_Expand_Label (Client_Handshake_Traffic_Secret, "finished", Get_Hash (Empty_Hash), Hash_Length)
      - Verify_Data := HMAC (Finished_Key, Get_Hash (Transcript_Hash))
      - Check Finished.Verify_Data = Verify_Data
      - Transcript_Hash := Update_Hash (Transcript_Hash, Finished_Message'Payload)
      - Master_Secret := HKDF_Extract (Derived_Handshake_Secret, 0)
      - Derived_Handshake_Secret := null
      - Client_Application_Traffic_Secret := Derive_Secret (Master_Secret, "c ap traffic", Get_Hash (Transcript_Hash))
      - Server_Application_Traffic_Secret := Derive_Secret (Master_Secret, "s ap traffic", Get_Hash (Transcript_Hash))
      - Resumption_Master_Secret := Derive_Secret (Master_Secret, "res master", Get_Hash (Transcript_Hash))
      - Master_Secret := null
    transitions:
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: Finished invalid
      - target: SEND_END_OF_EARLY_DATA
        condition: Early_Data_Received = True
      - target: CHECK_CERTIFICATE_CONDITIONS
        condition: Early_Data_Received = False

  - name: SEND_END_OF_EARLY_DATA
    actions:
      - Send EndOfEarlyData to Record_Data_Channel
    transitions:
      - target: CHECK_CERTIFICATE_CONDITIONS

  - name: CHECK_CERTIFICATE_CONDITIONS
    actions:
      - Check Certificate_Request_Received
      - Read available certificates from Configuration
      - Filter certificates compatible with Certificate_Authorities if Certificate_Authorities_Received
      - Filter certificates compatible with OID_Filters if OID_Filters_Received
      - Filter certificates compatible with Signature_Algorithms if Signature_Algorithms_Received and not Signature_Algorithms_Cert_Received
      - Filter certificates compatible with Signature_Algorithms_Cert if Signature_Algorithms_Cert_Received
    transitions:
      - target: SEND_FINISHED
        name: Certificate_Request_Received = False
      - target: SEND_CERTIFICATE
        condition: Certificate_Request_Received = True and certificates is non-empty
      - target: SEND_EMPTY_CERTIFICATE
        condition: Certificate_Request_Received = True and certificates is empty

  - name: SEND_CERTIFICATE
    actions:
      - Do OCSP request based on selected certificate and Status_Request if Status_Request_Received
      - Create Certificate using Configuration
      - Send Certificate to Record_Data_Channel
      - Transcript_Hash := Update_Hash (Transcript_Hash, Certificate_Message'Payload)
    transitions:
      - target: SEND_CERTIFICATE_VERIFY

  - name: SEND_EMPTY_CERTIFICATE
    actions:
      - Create empty Certificate
      - Send Certificate to Record_Data_Channel
      - Transcript_Hash := Update_Hash (Transcript_Hash, Certificate_Message'Payload)
    transitions:
      - target: SEND_FINISHED

  - name: SEND_CERTIFICATE_VERIFY
    actions:
      - Select one algorithm of Signature_Algorithms
      - Create CertificateVerify with Transcript_Hash using selected algorithm
      - Send CertificateVerify to Record_Data_Channel
      - Transcript_Hash := Update_Hash (Transcript_Hash, CertificateVerify_Message'Payload)
    transitions:
      - target: SEND_FINISHED

  - name: SEND_FINISHED
    actions:
      - Record_Data_Channel := send(Client_Handshake_Traffic_Secret, "Server_Write_Key")
      - Send Client_Handshake_Traffic_Secret to Record_Data_Channel as Server_Write_Key
      - Client_Handshake_Traffic_Secret := null
      - Verify_Data := HMAC (Finished_Key, Get_Hash (Transcript_Hash))
      - Finished_Key := null
      - Create Finished with Verify_Data
      - Send Finished to Record_Data_Channel
      - Send Client_Application_Traffic_Secret to Record_Data_Channel as Client_Write_Key
      - Send Server_Application_Traffic_Secret to Record_Data_Channel as Server_Write_Key
      - Server_Application_Traffic_Secret := null
    transitions:
      - target: CONNECTED

# FIXME: send KeyUpdate (periodically) based on Configuration
  - name: CONNECTED
    actions:
      - PostHandshakeMessage := read(Record_Data_Channel)
    transitions:
      - target: CONNECTED.NEW_SESSION_TICKET
        condition: PostHandshakeMessage.Tag = "NewSessionTicket"
      - target: CONNECTED.POST_HANDSHAKE_AUTH
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and Configuration.Post_Handshake_Auth_Enabled = True
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and Configuration.Post_Handshake_Auth_Enabled = False
      - target: CONNECTED.KEY_UPDATE
        condition: PostHandshakeMessage.Tag = "KeyUpdate"
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag /= "NewSessionTicket" and PostHandshakeMessage.Tag /= "CertificateRequest" and PostHandshakeMessage.Tag /= "KeyUpdate"

  - name: CONNECTED.NEW_SESSION_TICKET
    actions:
      - NewSessionTicket := PostHandshakeMessage
      - PSK := HKDF_Expand_Label (Resumption_Master_Secret, "resumption", NewSessionTicket.Ticket_Nonce, Hash_Length)
      - GreenTLS.Keystore_Message'Write (Keystore_Channel, GreenTLS.Keystore_Message (Connection, PSK, NewSessionTicket)
    transitions:
      - target: CONNECTED

  - name: CONNECTED.POST_HANDSHAKE_AUTH
    actions:
      - PhaCertificateRequest := PostHandshakeMessage
      - Pha_Extension_Position := 0
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR
    actions:
      - Pha_Extension_Type, Pha_Extension, Pha_Extension_Position, Pha_Result := Pha_Parse_Cr_Extension(PhaCertificateRequest.Extensions, Pha_Extension_Position)
      # FIXME: Signed_Certificate_Timestamp not supported
    transitions:
      - target: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
        condition: Pha_Extension_Type = "Status_Request"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: Pha_Extension_Type = "Certificate_Authorities"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
        condition: Pha_Extension_Type = "OID_Filters"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: Pha_Extension_Type = "Signature_Algorithms"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: Pha_Extension_Type = "Signature_Algorithms_Cert"
      - target: CONNECTED.PHA_PARSE_CR
        condition: Pha_Result = "unknown"
      - target: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
        condition: Pha_Result = "end"

  - name: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
    actions:
      - Pha_Status_Request_Received := True
      - Pha_Status_Request := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - Pha_Certificate_Authorities_Received := True
      - Pha_Certificate_Authorities := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
    actions:
      - Pha_OID_Filters_Received := True
      - Pha_OID_Filters := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - Pha_Signature_Algorithms_Received := True
      - Pha_Signature_Algorithms := Pha_Extension
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no supported signature algorithm
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - Pha_Signature_Algorithms_Cert_Received := True
      - Pha_Signature_Algorithms_Cert := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
    actions:
      - Pha_Transcript_Hash := Transcript_Hash
      - Update Pha_Transcript_Hash with PhaCertificateRequest
      - Check if Signature_Algorithms_Received = True
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: Signature_Algorithms_Received = False
      - target: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS

  - name: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS
    actions:
      - Read available Pha_Certificates from Configuration
      - Filter Pha_Certificates compatible with Pha_Certificate_Authorities if Pha_Certificate_Authorities_Received
      - Filter Pha_Certificates compatible with Pha_OID_Filters if Pha_OID_Filters_Received
      - Filter Pha_Certificates compatible with Pha_Signature_Algorithms if Pha_Signature_Algorithms_Received and not Signature_Algorithms_Cert_Received
      - Filter Pha_Certificates compatible with Pha_Signature_Algorithms_Cert if Pha_Signature_Algorithms_Cert_Received
    transitions:
      - target: CONNECTED.PHA_SEND_CERTIFICATE
        condition: Pha_Certificates is non-empty
      - target: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
        condition: Pha_Certificates is empty

  - name: CONNECTED.PHA_SEND_CERTIFICATE
    actions:
      - Do OCSP request based on selected certificate and Pha_Status_Request if Pha_Status_Request_Received
      - Create PhaCertificate using Configuration
      - Send PhaCertificate to Record_Data_Channel
    transitions:
      - target: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY

  - name: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
    actions:
      - Create empty PhaCertificate
      - Send PhaCertificate to Record_Data_Channel
    transitions:
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY
    actions:
      - Select one algorithm of Pha_Signature_Algorithms
      - Create PhaCertificateVerify with Pha_Transcript_Hash using selected algorithm
      - Send PhaCertificateVerify to Record_Data_Channel
    transitions:
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_FINISHED
    actions:
      - Finished_Key := HKDF_Expand_Label (Client_Application_Traffic_Secret, "finished", Get_Hash (Empty_Hash), Hash_Length)
      - Verify_Data := HMAC (Finished_Key, Get_Hash (Pha_Transcript_Hash))
      - Finished_Key := null
      - Create Finished with Verify_Data
      - Send Finished to Record_Data_Channel
    transitions:
      - target: CONNECTED

  - name: CONNECTED.KEY_UPDATE
    actions:
      - KeyUpdate := PostHandshakeMessage
      - Server_Application_Traffic_Secret = HKDF_Expand_Label (Server_Application_Traffic_Secret, "traffic upd", Get_Hash (Empty_Hash), Hash_Length)
      - Send Server_Application_Traffic_Secret to Record_Data_Channel as Server_Write_Key
      - Check KeyUpdate.Request_Update
    transitions:
      - target: CONNECTED.SEND_KEY_UPDATE
        condition: KeyUpdate.Request_Update == Update_Requested
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: KeyUpdate.Request_Update invalid
      - target: CONNECTED

  - name: CONNECTED.SEND_KEY_UPDATE
    actions:
      - Client_Application_Traffic_Secret = HKDF_Expand_Label (Client_Application_Traffic_Secret, "traffic upd", Get_Hash (Empty_Hash), Hash_Length)
      - Create and send KeyUpdate with Request_Update := Update_Not_Requested to Record_Data_Channel
      - Send Client_Application_Traffic_Secret to Record_Data_Channel as Client_Write_Key
    transitions:
      - target: CONNECTED

  - name: SEND_ALERT_ILLEGAL_PARAMETER
    actions:
      - Send Illegal_Parameter alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECODE_ERROR
    actions:
      - Send Decode_Error alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_BAD_CERTIFICATE
    actions:
      - Send Bad_Certificate alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_UNEXPECTED_MESSAGE
    actions:
      - Send Unexpected_Message alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECRYPT_ERROR
    actions:
      - Send Decrypt_Error alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_PROTOCOL_VERSION
    actions:
      - Send Protocol_Version alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_MISSING_EXTENSION
    actions:
      - Send Missing_Extension alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: ERROR.INTERNAL_ERROR
    transitions:
      - target: SEND_ALERT_INTERNAL_ERROR

  - name: SEND_ALERT_INTERNAL_ERROR
    actions:
      - Send Internal_Error alert
    transitions:
      - target: CONNECTION_TERMINATED

  - name: CONNECTION_TERMINATED
    actions:
      - Inform client application
    transitions:
      - target: FINAL

  - name: INVALID_CONFIGURATION
    actions:
      - Inform client application
    transitions:
      - target: SEND_ALERT_INTERNAL_ERROR

  - name: FINAL
