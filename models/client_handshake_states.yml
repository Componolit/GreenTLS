# supported extensions: server_name, max_fragment_length, supported_groups, signature_algorithms, use_srtp, heartbeat, application_layer_protocol_negotiation, client_certificate_type, server_certificate_type, padding, key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, post_handshake_auth, signature_algorithms_cert
# unsupported: signed_certificate_timestamp, status_request
# FIXME: "A peer which receives a handshake message in an unexpected order MUST abort the handshake with an "UNEXPECTED_Message" alert."
# FIXME: "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake."
# FIXME: It must be ensured that each extension type only exists once in an extension list.
# FIXME: Configuration component -> ROM
initial: START
final: FINAL
channels:
  - name: Record_Data_Channel
    type: TLS_Handshake.TLS_Handshake
    mode: Read_Write
  - name: Record_Control_Channel
    type: GreenTLS.Control_Message
    mode: Write
  - name: RNG_Channel
    type: Stream
    mode: Read
  - name: Keystore_Channel
    type: GreenTLS.Keystore_Message
    mode: Read_Write
  - name: Application_Control_Channel
    type: GreenTLS.Application_Control_Message
    mode: Read_Write
  - name: Configuration_Channel
    type: GreenTLS.Configuration
    mode: Read
  - name: Connection_Channel
    type: GreenTLS.Connection
    mode: Read
types:
  - "Hash_Context is private"
variables:
  - "Application_Layer_Protocol_Negotiation_Received : Boolean := False"
  - "Binders : TLS_Handshake.PSK_Binder_Entries := Initialize (4096 * 8)"
  - "CCR_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "CH_Cookie_Prepared : Boolean := False"
  - "CH_Key_Share_Prepared : Boolean := False"
  - "CH_PSK_Prepared : Boolean := False"
  - "Certificate_Authorities : TLS_Handshake.Certificate_Authorities := Initialize (4096 * 8)"
  - "Certificate_Authorities_Received : Boolean := False"
  - "Certificate_Request_Received : Boolean := False"
  - "Certificate_Request : TLS_Handshake.Certificate_Request := Initialize (4096 * 8)"
  - "Certificate_Verify_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Client_Application_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Client_Handshake_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Client_Hello_1_Hash : Hash_Context"
  - "Client_Hello_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Client_Shares : TLS_Handshake.Key_Share_Entries := Initialize (4096 * 8)"
  - "Connection : GreenTLS.Connection := Initialize (4096 * 8)"
  - "DHE_Accepted : Boolean := False"
  - "Derived_Handshake_Secret : GreenTLS.Content := Initialize (512)"
  - "Early_Data_Received : Boolean := False"
  - "Early_Secret : GreenTLS.Content := Initialize (512)"
  - "Encrypted_Extensions_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Error : TLS_Alert.Alert_Description"
  - "Extensions_List : TLS_Handshake.Extensions := Initialize (4096 * 8)"
  - "Finished_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Hash_Length : GreenTLS.KM_Length"
  - "Heartbeat_Received : Boolean := False"
  - "Identity_Index : TLS_Handshake.Identity_Index"
  - "Keystore_Message : GreenTLS.Keystore_Message := Initialize (192)"
  - "Max_Fragment_Length : TLS_Handshake.Max_Fragment_Length_Value"
  - "Max_Fragment_Length_Received : Boolean := False"
  - "OID_Filters : TLS_Handshake.OID_Filters := Initialize (4096 * 8)"
  - "OID_Filters_Received : Boolean := False"
  - "PSKs : GreenTLS.PSKs := Initialize (4096 * 8)"
  - "Pre_Shared_Key_CH : TLS_Handshake.Pre_Shared_Key_CH := Initialize (4096 * 8)"
  - "Resumption_Master_Secret : GreenTLS.Content := Initialize (512)"
  - "Retry_Request_Received : Boolean := False"
  - "Selected_Group : TLS_Handshake.Named_Group"
  - "Server_Application_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Server_Handshake_Traffic_Secret : GreenTLS.Content := Initialize (512)"
  - "Server_Hello_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
  - "Server_Name_Extension : TLS_Handshake.Extension := Initialize (4096 * 8)"
  - "Server_Name_Received : Boolean := False"
  - "Server_Preferred_Groups : TLS_Handshake.Supported_Groups := Initialize (176)"
  - "Signature_Algorithms : TLS_Handshake.Signature_Algorithms := Initialize (4096 * 8)"
  - "Signature_Algorithms_Cert : TLS_Handshake.Signature_Algorithms := Initialize (4096 * 8)"
  - "Signature_Algorithms_Cert_Received : Boolean := False"
  - "Signature_Algorithms_Received : Boolean := False"
  - "Success : Boolean"
  - "Supported_Groups : TLS_Handshake.Named_Groups := Initialize (160)"
  - "Supported_Groups_Received : Boolean := False"
  - "Transcript_Hash : Hash_Context"
renames:
  - "Certificate_Message : TLS_Handshake.Certificate renames CCR_Handshake_Message.Payload"
  - "Certificate_Request_Message : TLS_Handshake.Certificate_Request renames CCR_Handshake_Message.Payload"
  - "Certificate_Verify_Message : TLS_Handshake.Certificate_Verify renames Certificate_Verify_Handshake_Message.Payload"
  - "Client_Hello_Message : TLS_Handshake.Client_Hello renames Client_Hello_Handshake_Message.Payload"
  - "Encrypted_Extensions_Message : TLS_Handshake.Encrypted_Extensions renames Encrypted_Extensions_Handshake_Message.Payload"
  - "Finished_Message : TLS_Handshake.Finished renames Finished_Handshake_Message.Payload"
  - "Server_Hello_Message : TLS_Handshake.Server_Hello renames Server_Hello_Handshake_Message.Payload"
functions:
  - "Calculate_Binders (PSKs : GreenTLS.PSKs; Transcript_Hash : GreenTLS.Content) return TLS_Handshake.PSK_Binder_Entries"
  - "Calculate_Binders_Length (PSKs : GreenTLS.PSKs) return RFLX.Types.Bit_Length"
  - "Calculate_ECDHE_Key (Client_Share : TLS_Handshake.Key_Share_Entry; Server_Share : TLS_Handshake.Key_Share_Entry) return GreenTLS.Content"
  - "Derive_Secret (Secret : GreenTLS.Content; Label : String; Transcript_Hash : GreenTLS.Content) return GreenTLS.Content"
  - "Empty_Hash return Hash_Context"
  - "Get_Hash (Context : Hash_Context) return GreenTLS.Content"
  - "Get_Hash_Length (Cipher_Suite : TLS_Handshake.Cipher_Suite) return GreenTLS.KM_Length"
  - "Get_Zero_Content (Length : GreenTLS.KM_Length) return GreenTLS.Content"
  - "HKDF_Expand_Label (Secret : GreenTLS.Content; Label : String; Context : GreenTLS.Content; Length : GreenTLS.KM_Length) return GreenTLS.Content"
  - "HKDF_Extract (Salt : GreenTLS.Content; IKM : GreenTLS.Content) return GreenTLS.Content"
  - "HMAC (Cipher_Suite : TLS_Handshake.Cipher_Suite; Key : GreenTLS.Content; Hash : GreenTLS.Content) return GreenTLS.Content"
  - "Select_Supported_Groups (Server_Preferred_Groups : TLS_Handshake.Named_Groups; Supported_Groups : TLS_Handshake.Named_Groups) return TLS_Handshake.Named_Groups"
  - "Truncate_Client_Hello (Client_Hello : TLS_Handshake.Handshake) return GreenTLS.Content"
  - "Update_Hash (Context : Hash_Context; Data : Payload) return Hash_Context"
  - "Validate_Certificate_Verify_Signature (Certificate_Message : TLS_Handshake.Certificate; Certificate_Verify_Message : TLS_Handshake.Certificate_Verify; Transcript_Hash : GreenTLS.Content) return GreenTLS.Signature_Validation_Result"
  - "Validate_Server_Certificate (Certificate_Message : TLS_Handshake.Certificate; Configuration : GreenTLS.Configuration) return GreenTLS.Certificate_Validation_Result"
states:
  - name: START
    actions:
      - Connection := Read (Connection_Channel)
      - Configuration := Read (Configuration_Channel)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Connection'Valid = False
      - target: ERROR.INTERNAL_ERROR
        condition: Configuration'Valid = False
      - target: SERVER_PREFERRED_GROUPS

  - name: SERVER_PREFERRED_GROUPS
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS
      - target: SERVER_PREFERRED_GROUPS.CONFIGURE

  - name: SERVER_PREFERRED_GROUPS.CONFIGURE
    actions:
      - Server_Preferred_Groups := TLS_Handshake.Supported_Groups (Keystore_Message.Payload);
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Server_Preferred_Groups'Valid = False
      - target: SERVER_PREFERRED_GROUPS.SELECT

  - name: SERVER_PREFERRED_GROUPS.SELECT
    actions:
      - Supported_Groups := Select_Supported_Groups (Server_Preferred_Groups.Supported_Groups, Configuration.Supported_Groups)
    transitions:
      - target: CREATE_CLIENT_HELLO_EXTENSIONS

  - name: CREATE_CLIENT_HELLO_EXTENSIONS
    variables:
      - "Supported_Version : TLS_Handshake.Supported_Version := Initialize (16)"
      - "Supported_Versions_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
    actions:
      - Supported_Version := TLS_Handshake.Supported_Version'(Version => TLS_Handshake.TLS_1_3)
      - Supported_Versions_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS, Data_Length => Supported_Version'Length, Data => Supported_Version)
      - Extensions_List'Append (Supported_Versions_Extension)
      - Extensions_List'Extend (Create_Client_Hello_Extensions (Configuration))  # FIXME: define function
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.POST_HANDSHAKE_AUTH_EXTENSION
        condition: Configuration.Post_Handshake_Auth_Enabled = True
      - target: START.DHE
        condition: TLS_Handshake.PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: ERROR.INTERNAL_ERROR

  - name: START.POST_HANDSHAKE_AUTH_EXTENSION
    variables:
      - "Post_Handshake_Auth_Extension : TLS_Handshake.CH_Extension := Initialize (32)"
    actions:
      - Post_Handshake_Auth_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_POST_HANDSHAKE_AUTH, Data_Length => 0)
      - Extensions_List'Append (Post_Handshake_Auth_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.DHE
        condition: TLS_Handshake.PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: ERROR.INTERNAL_ERROR

  - name: START.DHE
    variables:
      - "Supported_Groups_Extension : TLS_Handshake.CH_Extension := Initialize (208)"
      - "Key_Share_Extension : TLS_Handshake.CH_Extension := Initialize (4096 * 8)"
      - "Signature_Algorithms_Extension : TLS_Handshake.CH_Extension := Initialize (320)"
    actions:
      - Supported_Groups_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SUPPORTED_GROUPS, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Supported_Groups'(Length => Configuration.Supported_Groups_Length, Groups => Configuration.Supported_Groups)
      - Extensions_List'Append (Supported_Groups_Extension)
      - Key_Share_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_KEY_SHARE, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Key_Share'(Length => Configuration.Key_Shares_Length, Shares => Configuration.Key_Shares)
      - Extensions_List'Append (Key_Share_Extension)
      - Signature_Algorithms_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Signature_Algorithms'(Length => Configuration.Signature_Algorithms_Length, Algorithms => Configuration.Signature_Algorithms)
      - Extensions_List'Append (Signature_Algorithms_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.DHE_SIGNATURE_ALGORITHMS
        condition: Configuration.Server_Authentication_Enabled = True
        doc: rfc8446.txt+2259:43-2261:36
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.SEND

  - name: START.DHE_SIGNATURE_ALGORITHMS
    variables:
      - "Signature_Algorithms_Cert_Extension : TLS_Handshake.CH_Extension := Initialize (320)"
    actions:
      - Signature_Algorithms_Cert_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.Signature_Algorithms_Cert'(Length => Configuration.Signature_Algorithms_Cert_Length, Algorithms => Configuration.Signature_Algorithms_Cert)
      - Extensions_List'Append (Signature_Algorithms_Cert_Extension)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.PSK
        condition: TLS_Handshake.PSK_KE in Configuration.PSK_Key_Exchange_Modes
      - target: START.SEND

  - name: START.PSK
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSK_IDENTITIES or (Keystore_Message.Length = 0 and TLS_Handshake.PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes)
      - target: START.SEND
        condition: Keystore_Message.Length = 0
      - target: START.PSK_EXTENSION_CHECK

  - name: START.PSK_EXTENSION_CHECK
    variables:
      - "PSK_Identities : TLS_Handshake.PSK_Identities := Initialize (4096 * 8)"
    actions:
      - PSKs := GreenTLS.PSK_Message (Keystore_Message.Payload).PSKs
      - Binders_Length := Calculate_Binders_Length (PSKs)
      - PSK_Identities := [for K in PSKs => K.Identity]
      - Pre_Shared_Key_CH := TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => null)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Pre_Shared_Key_CH'Valid = False
      - target: START.PSK_EXTENSIONS

  - name: START.PSK_EXTENSIONS
    variables:
      - "PSK_Key_Exchange_Modes_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
      - "Client_Hello_Hash : Hash_Context"
    actions:
      - PSK_Key_Exchange_Modes_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes)
      - Extensions_List'Append (PSK_Key_Exchange_Modes_Extension)
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Client_Hello_Hash := Empty_Hash
      - Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque)
      - Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash))
      - Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY]
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH) where PSK_CH = TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => Binders)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: START.SEND

  - name: START.SEND
    variables:
      - "Random : GreenTLS.Content := Initialize (32 * 8)"
    actions:
      - Random := Read (RNG_Channel)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message)
      - Client_Hello_1_Hash := Empty_Hash
      - Client_Hello_1_Hash := Update_Hash (Client_Hello_1_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque)
      - Transcript_Hash := Empty_Hash
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque)
      - Client_Hello_Message := Handshake.Client_Hello (Client_Hello_Handshake_Message.Payload)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: START.SEND_CLIENT_EARLY_TRAFFIC_SECRET
        condition: Configuration.Early_Data_Enabled = True
      - target: WAIT_SH

  - name: START.SEND_CLIENT_EARLY_TRAFFIC_SECRET
    variables:
      - "Client_Early_Traffic_Secret : GreenTLS.Content := Initialize (512)"
      - "Client_Write_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Write_IV : GreenTLS.Content := Initialize (512)"
    actions:
      - Early_Secret := HKDF_Extract (Get_Zero_Content (Get_Hash_Length (PSKs (0).Cipher_Suite)), GreenTLS.Content (Data => PSKs (0).Key))
      - Client_Early_Traffic_Secret := Derive_Secret (Early_Secret.Data, "c e traffic", Get_Hash (Transcript_Hash))
      - Client_Write_Key := HKDF_Expand_Label (Client_Early_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Write_IV := HKDF_Expand_Label (Client_Early_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Keystore_Message := null
      - Success := Write (Record_Data_Channel, GreenTLS.Control_Message (Tag => KEY_UDPATE_CLIENT, Length => KU'Length, Payload => KU) where KU = GreenTLS.Key_Update_Message'(Key_Length => Client_Write_Key'Length, Key => Client_Write_Key.Data, IV_Length => Client_Write_IV'Length, IV => Client_Write_IV.Data))
      - Client_Early_Traffic_Secret := null
      - Client_Write_Key := null
      - Client_Write_IV := null
    doc: rfc8446.txt+2938:43-2940:30
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_SH

  - name: WAIT_SH
    actions:
      - Server_Hello_Handshake_Message := Read (Record_Data_Channel)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Server_Hello_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.DECODE_ERROR
        condition: Server_Hello_Handshake_Message'Valid = False
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: Server_Hello_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_SERVER_HELLO
      - target: ERROR.DECODE_ERROR
        condition: Server_Hello_Message'Valid = False
      - target: ERROR.PROTOCOL_VERSION
        condition: Server_Hello_Message.Legacy_Version /= GreenTLS.TLS_1_2
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Server_Hello_Message.Legacy_Session_Id_Echo /= 0 or Server_Hello_Message.Legacy_Compression_Method /= 0
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Server_Hello_Message.Cipher_Suite not in Client_Hello_Message.Cipher_Suites
      - target: ERROR.MISSING_EXTENSION
        condition: for all E in Server_Hello_Message.Extensions => E.Tag /= TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Server_Hello_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS and (GreenTLS.TLS_1_3 not in TLS_Handshake.Supported_Versions (E.Data).Versions))
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Server_Hello_Message.Extensions => E not in Client_Hello_Message.Extensions
      - target: ERROR.ILLEGAL_PARAMETER
        condition: PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes and (for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE)
        doc: rfc8446.txt+2770:46-2771:59
      - target: WAIT_SH.PARSE_HRR
        condition: Server_Hello_Message.HRR_Extensions'Present and Retry_Request_Received = False
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: Server_Hello_Message.HRR_Extensions'Present = False and Retry_Request_Received = True
      - target: WAIT_SH.EXTENSIONS_PSK
        condition: for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY
        doc: rfc8446.txt+643:57-646:21
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
        doc: rfc8446.txt+640:45-642:47
      - target: ERROR.INVALID_CONFIGURATION

  - name: WAIT_SH.EXTENSIONS_PSK
    actions:
      - Identity_Index := TLS_Handshake.Pre_Shared_Key_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY]'Head.Data).Selected_Identity
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Identity_Index /= 0 and (for some E in Server_Hello_Message.Extensions => E.Tag = EXTENSION_EARLY_DATA)
        doc: rfc8446.txt+3199:4-3202:29
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Client_Hello_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY and TLS_Handshake.Pre_Shared_Key_CH (E.Data).Identities'Length < Identity_Index)
      - target: WAIT_SH.EXTENSIONS_PSK_REQUEST

  - name: WAIT_SH.EXTENSIONS_PSK_REQUEST
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message (Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSK, Length => Selected_Identity'Length, Payload => Selected_Identity) where Selected_Identity = TLS_Handshake.Pre_Shared_Key_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY]'Head.Data).Identities (Identity_Index))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSK or GreenTLS.PSK (Keystore_Message.Payload)'Valid = False
      - target: WAIT_SH.EXTENSIONS_PSK_VALIDATION

  - name: WAIT_SH.EXTENSIONS_PSK_VALIDATION
    variables:
      - "Identity_Cipher_Suite : TLS_Handshake.Cipher_Suite"
    actions:
      - Identity_Cipher_Suite := GreenTLS.PSK (Keystore_Message.Payload).Cipher_Suite
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Identity_Cipher_Suite /= Server_Hello_Message.Cipher_Suite
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
        doc:
          - rfc8446.txt+2765:4-2766:36
          - rfc8446.txt+646:24-647:60
      - target: SET_RECORD_KEYS

  - name: WAIT_SH.EXTENSIONS_DHE
    actions:
      - Selected_Group := TLS_Handshake.Key_Share_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]'Head.Data).Group
      - DHE_Accepted := True
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: (for some S in TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]'Head.Data).Shares => S.Group = Selected_Group) = False
        doc: rfc8446.txt+2766:39-2768:55
      - target: SET_RECORD_KEYS

  - name: WAIT_SH.PARSE_HRR
    variables:
      - "Client_Supported_Groups : TLS_Handshake.Named_Groups := Initialize (160)"
    actions:
      - Retry_Request_Received := True
      - Client_Supported_Groups := TLS_Handshake.Supported_Groups ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS]'Head.Data).Groups
      - Client_Shares := TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]'Head.Data).Shares
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Server_Hello_Message.Extensions => E not in Client_Hello_Message.Extensions and E.Tag /= TLS_Handshake.EXTENSION_COOKIE
        doc: rfc8446.txt+1825:70-1829:28
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE and (TLS_Handshake.Key_Share_HRR (E.Data).Selected_Group not in Client_Supported_Groups)
        doc: rfc8446.txt+2736:21-2738:23
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE and (for some S in Client_Shares => S.Group = TLS_Handshake.Key_Share_HRR (E.Data).Selected_Group)
        doc: rfc8446.txt+2738:29-2740:31
      - target: WAIT_SH.PREPARE_CH

  - name: WAIT_SH.PREPARE_CH
    actions:
      - Extensions_List'Reset
      - Extensions_List'Extend ([for E in Client_Hello_Message.Extensions => E when E.Tag /= TLS_Handshake.EXTENSION_KEY_SHARE and E.Tag /= TLS_Handshake.EXTENSION_EARLY_DATA and E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY])
    doc: rfc8446.txt+1497:7-1498:70
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_DISPATCH
    actions:
    transitions:
      - target: WAIT_SH.PREPARE_CH_KEY_SHARE
        condition: CH_Key_Share_Prepared = False and for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE
      - target: WAIT_SH.PREPARE_CH_COOKIE
        condition: CH_Cookie_Prepared = False and for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_COOKIE
      - target: WAIT_SH.PREPARE_CH_PSK
        condition: CH_PSK_Prepared = False and for some E in Server_Hello_Message.Extensions => E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY
      - target: WAIT_SH.SEND_CH

  - name: WAIT_SH.PREPARE_CH_KEY_SHARE
    actions:
      - Extensions_List'Append (TLS_Handshake.Extension'(Tag => EXTENSION_KEY_SHARE, Data_Length => Key_Share'Length, Data => Key_Share)) where Key_Share = TLS_Handshake.Key_Share_CH'(Length => Entries'Length, Shares => Entries) where Entries = [for E in Client_Shares => E when E.Group = Selected_Group]
      - CH_Key_Share_Prepared := True
    doc: rfc8446.txt+2742:12-2753:39
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_COOKIE
    actions:
      - Extensions_List'Append ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_COOKIE]'Head)
      - CH_Cookie_Prepared := True
    doc: rfc8446.txt+2223:19-2225:47
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.PREPARE_CH_PSK
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection))
    doc: rfc8446.txt+1519:7-1520:51
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or Keystore_Message.Tag /= KEYSTORE_RESPONSE or Keystore_Message.Request /= KEYSTORE_REQUEST_PSKS or (Keystore_Message.Length = 0 and TLS_Handshake.PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes) or GreenTLS.PSK_Message (Keystore_Message.Payload)'Valid = False
      - target: WAIT_SH.NO_PSK_EXTENSION
        condition: Keystore_Message.Length = 0
      - target: WAIT_SH.PSK_EXTENSION_CHECK

  - name: WAIT_SH.PSK_EXTENSION_CHECK
    variables:
      - "PSK_Identities : TLS_Handshake.PSK_Identities := Initialize (4096 * 8)"
    actions:
      - PSKs := [for K in GreenTLS.PSK_Message (Keystore_Message.Payload).PSKs => K when K.Cipher_Suite = Server_Hello.Cipher_Suite]
      - Binders_Length := Calculate_Binders_Length (PSKs)
      - PSK_Identities := [for K in PSKs => K.Identity]
      - Pre_Shared_Key_CH := TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => null)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Pre_Shared_Key_CH'Valid = False
      - target: WAIT_SH.PSK_EXTENSIONS

  - name: WAIT_SH.PSK_EXTENSIONS
    variables:
      - "PSK_Key_Exchange_Modes_Extension : TLS_Handshake.CH_Extension := Initialize (48)"
      - "Client_Hello_Hash : Hash_Context"
    actions:
      - PSK_Key_Exchange_Modes_Extension := TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes) where Modes = TLS_Handshake.PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes)
      - Extensions_List'Append (PSK_Key_Exchange_Modes_Extension)
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH)
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Client_Hello_Hash := Empty_Hash
      - Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque)
      - Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash))
      - Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake.EXTENSION_PRE_SHARED_KEY]
      - Extensions_List'Append (TLS_Handshake.CH_Extension'(Tag => TLS_Handshake.EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH) where PSK_CH = TLS_Handshake.Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Length, Binders => Binders)
      - CH_PSK_Prepared := True
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Extensions_List'Valid = False
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.NO_PSK_EXTENSION
    actions:
      - CH_PSK_Prepared := True
    transitions:
      - target: WAIT_SH.PREPARE_CH_DISPATCH

  - name: WAIT_SH.SEND_CH
    variables:
      - "Random : GreenTLS.Content := Initialize (32 * 8)"
      - "Transcript_Hash_2 : GreenTLS.Content := Initialize (512)"
    actions:
      - Transcript_Hash_2 := Empty_Hash
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, TLS_Handshake.Handshake'(Tag => HANDSHAKE_MESSAGE_HASH, Length => CH1_Hash'Length, Payload => CH1_Hash.Data)'Opaque) where CH1_Hash := Get_Hash (Client_Hello_1_Hash)
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Server_Hello_Handshake_Message'Opaque)
      - Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque)
      - Random := Client_Hello_Message.Random
      - Client_Hello_Handshake_Message'Reset
      - Client_Hello_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH) where CH = TLS_Handshake.Client_Hello'(Legacy_Version => TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List)
      - Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque)
    doc: rfc8446.txt+3264:4-3275:42
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_SH

  - name: SET_RECORD_KEYS
    variables:
      - "Derived_Early_Secret : GreenTLS.Content := Initialize (512)"
      - "Handshake_Secret : GreenTLS.Content := Initialize (512)"
      - "Client_Read_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Read_IV : GreenTLS.Content := Initialize (512)"
      - "Client_Write_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Write_IV : GreenTLS.Content := Initialize (512)"
      - "Success_Client : Boolean"
      - "Success_Server : Boolean"
    actions:
      - Derived_Early_Secret := Derive_Secret (Early_Secret, "derived", Get_Hash (Empty_Hash))
      - Early_Secret := null
      - Handshake_Secret := HKDF_Extract (Derived_Early_Secret, Key) where Key = Calculate_ECDHE_Key (Client_Share, TLS_Handshake.Key_Share_Entry ([for E in Server_Hello_Message.Extensions => E when E.Tag = EXTENSION_KEY_SHARE]'Head).Data) where Client_Share = [for S in TLS_Handshake.Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE]'Head.Data).Shares => S when S.Group = Selected_Group]'Head
      - Derived_Early_Secret := null
      - Client_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "c hs traffic", Get_Hash (Transcript_Hash))
      - Server_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "s hs traffic", Get_Hash (Transcript_Hash))
      - Client_Read_Key := HKDF_Expand_Label (Server_Handshake_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Read_IV := HKDF_Expand_Label (Server_Handshake_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Client_Write_Key := HKDF_Expand_Label (Client_Handshake_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Write_IV := HKDF_Expand_Label (Client_Handshake_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Success_Client := Write (Record_Control_Channel, GreenTLS.Control_Message (Tag => KEY_UPDATE_CLIENT, Length => Data'Length, Data => Data) where Data = GreenTLS.Record_Keys'(Key_Length => Client_Write_Key'Length, Key => Client_Write_Key.Data, IV_Length => Client_Write_IV'Length, IV => Client_Write_IV.Data)
      - Success_Server := Write (Record_Control_Channel, GreenTLS.Control_Message (Tag => KEY_UPDATE_SERVER, Length => Data'Length, Data => Data) where Data = GreenTLS.Record_Keys'(Key_Length => Client_Read_Key'Length, Key => Client_Read_Key.Data, IV_Length => Client_Read_IV'Length, IV => Client_Read_IV.Data)
      - Server_Handshake_Traffic_Secret := null
      - Client_Read_Key := null
      - Client_Read_IV := null
      - Client_Write_Key := null
      - Client_Write_IV := null
      - Derived_Handshake_Secret := Derive_Secret (Handshake_Secret, "derived", Get_Hash (Empty_Hash))
      - Handshake_Secret := null
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success_Client = False or Success_Server = False
      - target: WAIT_EE

  - name: WAIT_EE
    actions:
      - Encrypted_Extensions_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
    transitions:
      - target: ERROR.DECODE_ERROR
        condition: Encrypted_Extensions_Handshake_Message'Valid = False
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: Encrypted_Extensions_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_ENCRYPTED_EXTENSIONS
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PARSE_EXTENSIONS
    actions:
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_STATUS_REQUEST or E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS or E.Tag = TLS_Handshake.EXTENSION_SIGNED_CERTIFICATE_TIMESTAMP or E.Tag = TLS_Handshake.EXTENSION_PADDING or E.Tag = TLS_Handshake.EXTENSION_KEY_SHARE or E.Tag = TLS_Handshake.EXTENSION_PRE_SHARED_KEY or E.Tag = TLS_Handshake.EXTENSION_PSK_KEY_EXCHANGE_MODES or E.Tag = TLS_Handshake.EXTENSION_COOKIE or E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_VERSIONS or E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES or E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS or E.Tag = TLS_Handshake.EXTENSION_POST_HANDSHAKE_AUTH or E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT)
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Server_Name_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME)) and Configuration.Server_Name_Enabled = False
        doc: rfc6066.txt+376:46-378:16
      - target: WAIT_EE.PROCESS_SERVER_NAME
        condition: Server_Name_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME))
      - target: WAIT_EE.PROCESS_MAX_FRAGMENT_LENGTH
        condition: Max_Fragment_Length_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_MAX_FRAGMENT_LENGTH))
      - target: WAIT_EE.PROCESS_SUPPORTED_GROUPS
        condition: Supported_Groups_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS))
      - target: WAIT_EE.PROCESS_HEARTBEAT
        condition: Heartbeat_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_HEARTBEAT))
      - target: WAIT_EE.PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
        condition: Application_Layer_Protocol_Negotiation_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION))
      - target: WAIT_EE.PROCESS_EARLY_DATA
        condition: Early_Data_Received = False and (for some E in Encrypted_Extensions_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_EARLY_DATA))
      - target: WAIT_EE.CHECK_EXTENSIONS

  - name: WAIT_EE.PROCESS_SERVER_NAME
    actions:
      - Server_Name_Extension := [for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SERVER_NAME]'Head  # FIXME: never used yet
      - Server_Name_Received := True
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Server_Name_Extension.Data_Length > 0
        doc: rfc6066.txt+378:19-379:9
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_MAX_FRAGMENT_LENGTH
    actions:
      - Max_Fragment_Length := TLS_Handshake.Max_Fragment_Length ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_MAX_FRAGMENT_LENGTH]'Head.Data).Max_Fragment_Length
      - Max_Fragment_Length_Received := True
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Configuration.Max_Fragment_Length /= Max_Fragment_Length
        doc: rfc6066.txt+435:50-438:32
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_SUPPORTED_GROUPS
    actions:
      - Server_Preferred_Groups := TLS_Handshake.Supported_Groups ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SUPPORTED_GROUPS]'Head.Data).Groups  # FIXME: store after successful handshake
      - Supported_Groups_Received := True
    doc: rfc8446.txt+2651:4-2661:68
    transitions:
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_HEARTBEAT
    variables:
      - "Server_Heartbeat_Mode : TLS_Handshake.Heartbeat_Mode"
    actions:
      - Server_Heartbeat_Mode := TLS_Handshake.Heartbeat ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_HEARTBEAT]'Head.Data).Mode
      - Success := Write (Record_Control_Channel, GreenTLS.Control_Message'(Tag => GreenTLS.HEARTBEAT_MODE, Length => Data'Length, Payload => Data) where Data = GreenTLS.Heartbeat_Control_Message'(Local => Configuration.Heartbeat_Mode, Remote => Server_Heartbeat_Mode))
      - Heartbeat_Received := True
    doc: rfc6520.txt+138:4-149:61
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
    variables:
      - "Protocols : TLS_Handshake.Protocol_Names := Initialize (4096 * 8)"
    actions:
      - Protocols := TLS_Handshake.Protocol_Name_List ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION]'Head.Data).Protocol_Name_List
      - Success := Write (Application_Control_Channel, GreenTLS.Application_Control_Message'(GreenTLS.APPLICATION_PROTOCOL, Protocols'Head))
      - Application_Layer_Protocol_Negotiation_Received := True
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Protocols'Length /= 1
        doc: rfc7301.txt+181:53-185:30
      - target: ERROR.ILLEGAL_PARAMETER
        condition: (for all P in Configuration.Protocols => P /= Protocols'Head)
        doc: rfc7301.txt+175:4-177:54
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.PROCESS_EARLY_DATA
    actions:
      - Early_Data_Received := True
    doc: rfc8446.txt+2993:7-2998:45
    transitions:
      - target: WAIT_EE.PARSE_EXTENSIONS

  - name: WAIT_EE.CHECK_EXTENSIONS
    actions:
      - Transcript_Hash := Update_Hash (Transcript_Hash, Encrypted_Extensions_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.MISSING_EXTENSION
        condition: Configuration.Server_Name_Enabled = True and Server_Name_Received = False
      - target: ERROR.MISSING_EXTENSION
        condition: Configuration.Max_Fragment_Length_Enabled = True and Max_Fragment_Length_Received = False
      - target: WAIT_EE.NO_EARLY_DATA
        condition: Configuration.Early_Data_Enabled = True and Early_Data_Received = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.NO_EARLY_DATA
    actions:
      - Success := Write (Application_Control_Channel, GreenTLS.Application_Control_Message'(Tag => APPLICATION_NO_EARLY_DATA, Length => Data'Length, Data => Data) where GreenTLS.Application_No_Early_Data_Message'(null message))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.DISPATCH
    actions:
    transitions:
      - target: WAIT_CERT_CR
        condition: DHE_Accepted = True
      - target: WAIT_FINISHED

  - name: WAIT_CERT_CR
    actions:
      - CCR_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
      - Certificate_Authorities := TLS_Handshake.Certificate_Authorities'(Length => 0)
      - OID_Filters := TLS_Handshake.OID_Filters'(Length => 0)
      - Signature_Algorithms := TLS_Handshake.Signature_Algorithms'(Length => 0)
      - Signature_Algorithms_Cert := TLS_Handshake.Signature_Algorithms_Cert'(Length => 0)
    transitions:
      - target: ERROR.DECODE_ERROR
        condition: CCR_Handshake_Message'Valid = False
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: CCR_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_CERTIFICATE and CCR_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_CERTIFICATE_REQUEST
      - target: PARSE_CERT
        condition: Certificate_Message'Valid = True
      - target: PARSE_CR
        condition: Certificate_Request_Message'Valid = True
      - target: ERROR.DECODE_ERROR

  - name: PARSE_CR
    actions:
      - Certificate_Request := TLS_Handshake.Certificate_Request'(Certificate_Request_Context_Length => Certificate_Request_Message.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request_Message.Certificate_Request_Context, Extensions_Length => Certificate_Request_Message.Extensions_Length, Extensions => Certificate_Request_Message.Extensions)
    transitions:
      - target: PARSE_CR.EXTENSIONS

  - name: PARSE_CR.EXTENSIONS
    actions:
      - Certificate_Request_Received := True
    transitions:
      - target: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: Certificate_Authorities_Received = False and (for some E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES))
      - target: PARSE_CR.PARSE_OID_FILTERS
        condition: OID_Filters_Received = False and (for some E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS))
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: Signature_Algorithms_Received = False and (for some E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS))
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: Signature_Algorithms_Cert_Received = False and (for some E in Certificate_Request_Message.Extensions => (E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT))
      - target: PARSE_CR.CHECK_EXTENSIONS

  - name: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - Certificate_Authorities_Received := True
      - Certificate_Authorities := TLS_Handshake.Certificate_Authorities ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_CERTIFICATE_AUTHORITIES]'Head.Data)
    transitions:
      - target: PARSE_CR.EXTENSIONS

  - name: PARSE_CR.PARSE_OID_FILTERS
    actions:
      - OID_Filters_Received := True
      - OID_Filters := TLS_Handshake.OID_Filters ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_OID_FILTERS]'Head.Data)
    transitions:
      - target: PARSE_CR.EXTENSIONS

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - Signature_Algorithms_Received := True
      - Signature_Algorithms := TLS_Handshake.Signature_Algorithms ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS]'Head.Data)
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for all A in Configuration.Signature_Algorithms => A not in Signature_Algorithms
      - target: PARSE_CR.EXTENSIONS

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - Signature_Algorithms_Cert_Received := True
      - Signature_Algorithms_Cert := TLS_Handshake.Signature_Algorithms_Cert ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake.EXTENSION_SIGNATURE_ALGORITHMS_CERT]'Head.Data)
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: for all A in Configuration.Signature_Algorithms_Cert => A not in Signature_Algorithms_Cert
      - target: PARSE_CR.EXTENSIONS

  - name: PARSE_CR.CHECK_EXTENSIONS
    actions:
      - Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.MISSING_EXTENSION
        condition: Signature_Algorithms_Received = False
      - target: WAIT_CERT

  - name: WAIT_CERT
    actions:
      - CCR_Handshake_Message := TLS_Handshake.Handshake'Read (Record_Data_Channel)
    transitions:
      - target: ERROR.DECODE_ERROR
        condition: CCR_Handshake_Message'Valid = False or Certificate_Message'Valid = False
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: CCR_Handshake_Message.Tag /= TLS_Handshake.HANDSHAKE_CERTIFICATE
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Certificate_Message.Certificate_Request_Context_Length /= 0
        doc: rfc8446.txt+3593:22-3594:38
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Certificate_Message.Certificate_List_Length = 0
        doc: rfc8446.txt+3649:4-3649:58
      - target: PARSE_CERT

  - name: PARSE_CERT
    variables:
      - "Validation_Result : GreenTLS.Certificate_Validation_Result"
    actions:
      - Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque)
      - Validation_Result := Validate_Server_Certificate (Certificate_Message, Configuration)
    transitions:
      - target: WAIT_CV
        condition: Certificate_Result = GreenTLS.VALID_CERTIFICATE
      - target: ERROR.BAD_CERTIFICATE
        condition: Certificate_Result = GreenTLS.BAD_CERTIFICATE
      - target: ERROR.UNSUPPORTED_CERTIFICATE
        condition: Certificate_Result = GreenTLS.UNSUPPORTED_CERTIFICATE
      - target: ERROR.CERTIFICATE_REVOKED
        condition: Certificate_Result = GreenTLS.CERTIFICATE_REVOKED
      - target: ERROR.CERTIFICATE_EXPIRED
        condition: Certificate_Result = GreenTLS.CERTIFICATE_EXPIRED
      - target: ERROR.CERTIFICATE_UNKNOWN
        condition: Certificate_Result = GreenTLS.CERTIFICATE_UNKNOWN
      - target: ERROR.INTERNAL_ERROR

  - name: WAIT_CV
    actions:
      - Certificate_Verify_Handshake_Message := Read (Record_Data_Channel)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Certificate_Verify_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.DECODE_ERROR
        condition: Certificate_Verify_Handshake_Message'Valid = False or Certificate_Verify_Message'Valid = False
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Certificate_Verify_Message.Algorithm not in Configuration.Signature_Algorithms
        doc: rfc8446.txt+3902:4-3904:12
      - target: WAIT_CV.VALIDATE

  - name: WAIT_CV.VALIDATE
    variables:
      - "Validation_Result : GreenTLS.Signature_Validation_Result"
    actions:
      - Validation_Result := Validate_Certificate_Verify_Signature (Certificate_Message, Certificate_Verify_Message, Get_Hash (Transcript_Hash))
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: Validation_Result = GreenTLS.ILLEGAL_PARAMETER
      - target: ERROR.DECRYPT_ERROR
        condition: Validation_Result = GreenTLS.DECRYPT_ERROR
      - target: WAIT_FINISHED
        condition: Validation_Result = GreenTLS.VALID_SIGNATURE
      - target: ERROR.INTERNAL_ERROR

  - name: WAIT_FINISHED
    variables:
      - "Finished_Key : GreenTLS.Content := Initialize (512)"
      - "Verify_Data : GreenTLS.Content := Initialize (4096 * 8)"
      - "Master_Secret : GreenTLS.Content := Initialize (512)"
    actions:
      - Hash_Length := Get_Hash_Length (Server_Hello_Message.Cipher_Suite)
      - Finished_Handshake_Message := Read (Record_Data_Channel)
      - Finished_Key := HKDF_Expand_Label (Client_Handshake_Traffic_Secret, "finished", Get_Hash (Empty_Hash), Hash_Length)
      - Client_Handshake_Traffic_Secret := null
      - Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash))
      - Transcript_Hash := Update_Hash (Transcript_Hash, Finished_Handshake_Message'Opaque)
      - Master_Secret := HKDF_Extract (Derived_Handshake_Secret, Get_Zero_Content (Hash_Length))
      - Derived_Handshake_Secret := null
      - Client_Application_Traffic_Secret := Derive_Secret (Master_Secret, "c ap traffic", Get_Hash (Transcript_Hash))
      - Server_Application_Traffic_Secret := Derive_Secret (Master_Secret, "s ap traffic", Get_Hash (Transcript_Hash))
      - Resumption_Master_Secret := Derive_Secret (Master_Secret, "res master", Get_Hash (Transcript_Hash))
      - Master_Secret := null
    transitions:
      - target: ERROR.DECRYPT_ERROR
        condition: Finished_Handshake_Message'Valid = False or Finished_Message'Valid = False or Finished_Message.Verify_Data /= Verify_Data
        doc: rfc8446.txt+3951:4-3953:25
      - target: SEND_END_OF_EARLY_DATA
        condition: Early_Data_Received = True
        doc: rfc8446.txt+4025:4-4027:19
      - target: CHECK_CERTIFICATE_REQUEST
        condition: Early_Data_Received = False
        doc: rfc8446.txt+4027:22-4029:26

  - name: SEND_END_OF_EARLY_DATA
    actions:
      - Success := Write (Record_Data_Channel, TLS_Handshake.Handshake'(Tag => HANDSHAKE_END_OF_EARLY_DATA, Length => 0))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: CHECK_CERTIFICATE_REQUEST

  - name: CHECK_CERTIFICATE_REQUEST
    actions:
    transitions:
      - target: SEND_FINISHED
        condition: Certificate_Request_Received = False
        doc: rfc8446.txt+3544:4-3546:19
      - target: QUERY_CERTIFICATES
        condition: Certificate_Request_Received = True

  - name: QUERY_CERTIFICATES
    actions:
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_CERTIFICATES, Length => Query'Length, Payload => Query) where Query = GreenTLS.Certificate_Query'(Certificate_Authorities => Certificate_Authorities, OID_Filters => OID_Filters, Signature_Algorithms => Signature_Algorithms, Signature_Algorithms_Cert => Signature_Algorithms_Cert))
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or GreenTLS.Certificate (Keystore_Message.Payload)'Valid = False
      - target: SEND_CERTIFICATE
        condition: GreenTLS.Certificate (Keystore_Message.Payload).Length > 0
      - target: SEND_EMPTY_CERTIFICATE
        condition: GreenTLS.Certificate (Keystore_Message.Payload).Length = 0
        doc: rfc8446.txt+3456:22-3549:26

  - name: SEND_CERTIFICATE
    variables:
      - "Client_Certificate_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
    actions:
      - Client_Certificate_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate) where Certificate = TLS_Handshake.Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => C.Length, Certificate_List => C.Certificate_List) where C = GreenTLS.Certificate (Keystore_Message.Payload)
      - Success := Write (Record_Data_Channel, Client_Certificate_Message)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: QUERY_SIGNATURE
        doc: rfc8446.txt+3829:24-3833:11

  - name: SEND_EMPTY_CERTIFICATE
    variables:
      - "Client_Certificate_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
    actions:
      - Client_Certificate_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate) where Certificate = TLS_Handshake.Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => 0)
      - Success := Write (Record_Data_Channel, Client_Certificate_Handshake_Message)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: SEND_FINISHED

  - name: QUERY_SIGNATURE
      - Keystore_Message := Call (Keystore_Channel, GreenTLS.Keystore_Message'(Tag => KEYSTORE_REQUEST, Request => KEYSTORE_REQUEST_SIGNATURE, Length => Query'Length, Payload => Query) where Query = GreenTLS.Signature_Query'(ID => GreenTLS.Certificate (Keystore_Message.Payload).ID, Length => Hash'Length, Data => Hash) where Hash = Get_Hash (Transcript_Hash).Data)
    actions:
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Keystore_Message'Valid = False or TLS_Handshake.Certificate_Verify (Keystore_Message.Payload)'Valid = False
      - target: SEND_CERTIFICATE_VERIFY

  - name: SEND_CERTIFICATE_VERIFY
    variables:
      - "Client_Certificate_Verify_Handshake_Message : TLS_Handshake.Handshake := Initialize (4096 * 8)"
    actions:
      - Client_Certificate_Verify_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_CERTIFICATE_VERIFY, Length => Certificate_Verify'Length, Payload => Certificate_Verify) where Certificate_Verify = TLS_Handshake.Certificate_Verify (Keystore_Message.Payload)
      - Success := Write (Record_Data_Channel, Client_Certificate_Verify_Handshake_Message)
      - Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Verify_Handshake_Message'Opaque)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: SEND_FINISHED

  - name: SEND_FINISHED
    variables:
      - "Verify_Data : GreenTLS.Content := Initialize (4096 * 8)"
    actions:
      - Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash))
      - Finished_Key := null
      - Finished_Handshake_Message := TLS_Handshake.Handshake'(Tag => HANDSHAKE_FINISHED, Length => Finished'Length, Payload => Finished) where Finished = TLS_Handshake.Finished (Verify_Data => Verify_Data)
      - Success := Write (Record_Data_Channel, Finished_Handshake_Message)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: SEND_APPLICATION_RECORD_KEYS

  - name: SEND_APPLICATION_RECORD_KEYS
    variables:
      - "Client_Read_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Read_IV : GreenTLS.Content := Initialize (512)"
      - "Client_Write_Key : GreenTLS.Content := Initialize (512)"
      - "Client_Write_IV : GreenTLS.Content := Initialize (512)"
      - "Success_Client : Boolean"
      - "Success_Server : Boolean"
    actions:
      - Client_Read_Key := HKDF_Expand_Label (Server_Application_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Read_IV := HKDF_Expand_Label (Server_Application_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Client_Write_Key := HKDF_Expand_Label (Client_Application_Traffic_Secret.Data, "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length)
      - Client_Write_IV := HKDF_Expand_Label (Client_Application_Traffic_Secret.Data, "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length)
      - Success_Client := Write (Record_Control_Channel, GreenTLS.Control_Message (Tag => KEY_UPDATE_CLIENT, Length => Data'Length, Data => Data) where Data = GreenTLS.Record_Keys'(Key_Length => Client_Write_Key'Length, Key => Client_Write_Key.Data, IV_Length => Client_Write_IV'Length, IV => Client_Write_IV.Data)
      - Success_Server := Write (Record_Control_Channel, GreenTLS.Control_Message (Tag => KEY_UPDATE_SERVER, Length => Data'Length, Data => Data) where Data = GreenTLS.Record_Keys'(Key_Length => Client_Read_Key'Length, Key => Client_Read_Key.Data, IV_Length => Client_Read_IV'Length, IV => Client_Read_IV.Data)
      - Server_Application_Traffic_Secret := null
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success_Client = False or Success_Server = False
      - target: CONNECTED

# FIXME: send KeyUpdate (periodically) based on Configuration
  - name: CONNECTED  # TODO: CONTINUE
    actions:
      - PostHandshakeMessage := Read (Record_Data_Channel)
    transitions:
      - target: CONNECTED.NEW_SESSION_TICKET
        condition: PostHandshakeMessage.Tag = "NewSessionTicket"
      - target: CONNECTED.POST_HANDSHAKE_AUTH
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and Configuration.Post_Handshake_Auth_Enabled = True
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and Configuration.Post_Handshake_Auth_Enabled = False
      - target: CONNECTED.KEY_UPDATE
        condition: PostHandshakeMessage.Tag = "KeyUpdate"
      - target: ERROR.UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag /= "NewSessionTicket" and PostHandshakeMessage.Tag /= "CertificateRequest" and PostHandshakeMessage.Tag /= "KeyUpdate"

  - name: CONNECTED.NEW_SESSION_TICKET
    actions:
      - NewSessionTicket := PostHandshakeMessage
      - PSK := HKDF_Expand_Label (Resumption_Master_Secret, "resumption", NewSessionTicket.Ticket_Nonce, Hash_Length)
      - GreenTLS.Keystore_Message'Write (Keystore_Channel, GreenTLS.Keystore_Message (Connection, PSK, NewSessionTicket)
    transitions:
      - target: CONNECTED

  - name: CONNECTED.POST_HANDSHAKE_AUTH
    actions:
      - PhaCertificateRequest := PostHandshakeMessage
      - Pha_Extension_Position := 0
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR
    actions:
      - Pha_Extension_Type, Pha_Extension, Pha_Extension_Position, Pha_Result := Pha_Parse_Cr_Extension(PhaCertificateRequest.Extensions, Pha_Extension_Position)
      # FIXME: Signed_Certificate_Timestamp not supported
    transitions:
      - target: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
        condition: Pha_Extension_Type = "Status_Request"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: Pha_Extension_Type = "Certificate_Authorities"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
        condition: Pha_Extension_Type = "OID_Filters"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: Pha_Extension_Type = "Signature_Algorithms"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: Pha_Extension_Type = "Signature_Algorithms_Cert"
      - target: CONNECTED.PHA_PARSE_CR
        condition: Pha_Result = "unknown"
      - target: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
        condition: Pha_Result = "end"

  - name: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
    actions:
      - Pha_Status_Request_Received := True
      - Pha_Status_Request := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - Pha_Certificate_Authorities_Received := True
      - Pha_Certificate_Authorities := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
    actions:
      - Pha_OID_Filters_Received := True
      - Pha_OID_Filters := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - Pha_Signature_Algorithms_Received := True
      - Pha_Signature_Algorithms := Pha_Extension
    transitions:
      - target: ERROR.ILLEGAL_PARAMETER
        condition: no supported signature algorithm
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - Pha_Signature_Algorithms_Cert_Received := True
      - Pha_Signature_Algorithms_Cert := Pha_Extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
    actions:
      - Pha_Transcript_Hash := Transcript_Hash
      - Update Pha_Transcript_Hash with PhaCertificateRequest
      - Check if Signature_Algorithms_Received = True
    transitions:
      - target: ERROR.MISSING_EXTENSION
        condition: Signature_Algorithms_Received = False
      - target: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS

  - name: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS
    actions:
      - Read available Pha_Certificates from Configuration
      - Filter Pha_Certificates compatible with Pha_Certificate_Authorities if Pha_Certificate_Authorities_Received
      - Filter Pha_Certificates compatible with Pha_OID_Filters if Pha_OID_Filters_Received
      - Filter Pha_Certificates compatible with Pha_Signature_Algorithms if Pha_Signature_Algorithms_Received and not Signature_Algorithms_Cert_Received
      - Filter Pha_Certificates compatible with Pha_Signature_Algorithms_Cert if Pha_Signature_Algorithms_Cert_Received
    transitions:
      - target: CONNECTED.PHA_SEND_CERTIFICATE
        condition: Pha_Certificates is non-empty
      - target: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
        condition: Pha_Certificates is empty

  - name: CONNECTED.PHA_SEND_CERTIFICATE
    actions:
      - Do OCSP request based on selected certificate and Pha_Status_Request if Pha_Status_Request_Received
      - Create PhaCertificate using Configuration
      - Success := Write (Record_Data_Channel, PhaCertificate)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY

  - name: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
    actions:
      - Create empty PhaCertificate
      - Success := Write (Record_Data_Channel, PhaCertificate)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY
    actions:
      - Select one algorithm of Pha_Signature_Algorithms
      - Create PhaCertificateVerify with Pha_Transcript_Hash using selected algorithm
      - Success := Write (Record_Data_Channel, PhaCertificateVerify)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_FINISHED
    actions:
      - Finished_Key := HKDF_Expand_Label (Client_Application_Traffic_Secret, "finished", Get_Hash (Empty_Hash), Hash_Length)
      - Verify_Data := HMAC (Finished_Key, Get_Hash (Pha_Transcript_Hash))
      - Finished_Key := null
      - Create Finished with Verify_Data
      - Success := Write (Record_Data_Channel, Finished)
    transitions:
      - target: ERROR.INTERNAL_ERROR
        condition: Success = False
      - target: CONNECTED

  - name: CONNECTED.KEY_UPDATE
    actions:
      - KeyUpdate := PostHandshakeMessage
      - Server_Application_Traffic_Secret = HKDF_Expand_Label (Server_Application_Traffic_Secret, "traffic upd", Get_Hash (Empty_Hash), Hash_Length)
      - Success := Write (Record_Data_Channel, Server_Application_Traffic_Secret) Server_Write_Key
      - Check KeyUpdate.Request_Update
    transitions:
      - target: CONNECTED.SEND_KEY_UPDATE
        condition: KeyUpdate.Request_Update == Update_Requested
      - target: ERROR.ILLEGAL_PARAMETER
        condition: KeyUpdate.Request_Update invalid
      - target: CONNECTED

  - name: CONNECTED.SEND_KEY_UPDATE
    actions:
      - Client_Application_Traffic_Secret = HKDF_Expand_Label (Client_Application_Traffic_Secret, "traffic upd", Get_Hash (Empty_Hash), Hash_Length)
      - Create and send KeyUpdate with Request_Update := Update_Not_Requested to Record_Data_Channel
      - Success := Write (Record_Data_Channel, Client_Application_Traffic_Secret) Client_Write_Key
    transitions:
      - target: CONNECTED

  - name: ERROR.INVALID_CONFIGURATION
    actions:
      - Error := TLS_Alert.ILLEGAL_PARAMETER
    transitions:
      - target: ERROR.SEND_LOCAL

  - name: ERROR.CLOSE_NOTIFY
    actions:
      - Error := TLS_Alert.CLOSE_NOTIFY
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNEXPECTED_MESSAGE
    actions:
      - Error := TLS_Alert.UNEXPECTED_MESSAGE
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.BAD_RECORD_MAC
    actions:
      - Error := TLS_Alert.BAD_RECORD_MAC
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.RECORD_OVERFLOW
    actions:
      - Error := TLS_Alert.RECORD_OVERFLOW
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.HANDSHAKE_FAILURE
    actions:
      - Error := TLS_Alert.HANDSHAKE_FAILURE
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.BAD_CERTIFICATE
    actions:
      - Error := TLS_Alert.BAD_CERTIFICATE
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNSUPPORTED_CERTIFICATE
    actions:
      - Error := TLS_Alert.UNSUPPORTED_CERTIFICATE
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.CERTIFICATE_REVOKED
    actions:
      - Error := TLS_Alert.CERTIFICATE_REVOKED
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.CERTIFICATE_EXPIRED
    actions:
      - Error := TLS_Alert.CERTIFICATE_EXPIRED
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.CERTIFICATE_UNKNOWN
    actions:
      - Error := TLS_Alert.CERTIFICATE_UNKNOWN
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.ILLEGAL_PARAMETER
    actions:
      - Error := TLS_Alert.ILLEGAL_PARAMETER
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNKNOWN_CA
    actions:
      - Error := TLS_Alert.UNKNOWN_CA
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.ACCESS_DENIED
    actions:
      - Error := TLS_Alert.ACCESS_DENIED
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.DECODE_ERROR
    actions:
      - Error := TLS_Alert.DECODE_ERROR
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.DECRYPT_ERROR
    actions:
      - Error := TLS_Alert.DECRYPT_ERROR
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.PROTOCOL_VERSION
    actions:
      - Error := TLS_Alert.PROTOCOL_VERSION
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.INSUFFICIENT_SECURITY
    actions:
      - Error := TLS_Alert.INSUFFICIENT_SECURITY
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.INTERNAL_ERROR
    actions:
      - Error := TLS_Alert.INTERNAL_ERROR
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.INAPPROPRIATE_FALLBACK
    actions:
      - Error := TLS_Alert.INAPPROPRIATE_FALLBACK
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.USER_CANCELED
    actions:
      - Error := TLS_Alert.USER_CANCELED
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.MISSING_EXTENSION
    actions:
      - Error := TLS_Alert.MISSING_EXTENSION
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNSUPPORTED_EXTENSION
    actions:
      - Error := TLS_Alert.UNSUPPORTED_EXTENSION
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNRECOGNIZED_NAME
    actions:
      - Error := TLS_Alert.UNRECOGNIZED_NAME
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.BAD_CERTIFICATE_STATUS_RESPONSE
    actions:
      - Error := TLS_Alert.BAD_CERTIFICATE_STATUS_RESPONSE
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.UNKNOWN_PSK_IDENTITY
    actions:
      - Error := TLS_Alert.UNKNOWN_PSK_IDENTITY
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.CERTIFICATE_REQUIRED
    actions:
      - Error := TLS_Alert.CERTIFICATE_REQUIRED
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.NO_APPLICATION_PROTOCOL
    actions:
      - Error := TLS_Alert.NO_APPLICATION_PROTOCOL
    transitions:
      - target: ERROR.SEND_REMOTE

  - name: ERROR.SEND_REMOTE
    actions:
      - Success := Write (Record_Control_Channel, GreenTLS.Control_Message'(Tag => ALERT, Length => Alert_Message'Length, Data => Alert_Message) where Alert_Message = GreenTLS.Alert_Message'(Description => Error))
    transitions:
      - target: ERROR.SEND_LOCAL

  - name: ERROR.SEND_LOCAL
    actions:
      - Success := Write (Application_Control_Channel, GreenTLS.Application_Control_Message'(Tag => GreenTLS.APPLICATION_ALERT, Length => Data'Length, Data => Data) where Data = GreenTLS.Alert_Message'(Description => Error))
    transitions:
      - target: FINAL

  - name: FINAL
