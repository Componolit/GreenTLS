initial: START
final: FINAL
# FIXME: "A peer which receives a handshake message in an unexpected order MUST abort the handshake with an "unexpected_message" alert."
# FIXME: "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake."
# FIXME: What is the semantic of channels?
states:
  - name: START
    actions:
      - retry_request_received := False
      - certificate_request_received := False
      - server_name_received := False
      - max_fragment_length_received := False
      - early_data_received := False
      - status_request_received := False
      - certificate_authorities_received := False
      - oid_filters_received := False
      - signature_algorithms_received := False
      - signature_algorithms_cert_received := False
      - server_certificate_type := X509
      - connection := read(application_in)
      - configuration := read(configuration_in)
      - server_prefered_groups := read(datastore_in)
      - supported_groups := select_supported_groups(server_prefered_groups, configuration.supported_groups)
    transitions:
      - target: INVALID_CONFIGURATION
        condition: configuration.key_exchange_mode.length = 0
      - target: INVALID_CONFIGURATION
        condition: configuration.cipher_suites.length = 0
      - target: CREATE_CLIENT_HELLO_EXTENSIONS

  - name: CREATE_CLIENT_HELLO_EXTENSIONS
      - extensions_list := list(supported_versions_extension(list(0x0304))))
      - client_hello_extensions := create_client_hello_extensions(configuration)  # supported: server_name, max_fragment_length, status_request, supported_groups, signature_algorithms, use_srtp, heartbeat, application_layer_protocol_negotiation, client_certificate_type, server_certificate_type, padding, key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, post_handshake_auth, signature_algorithms_cert | FIXME unsupported: signed_certificate_timestamp
      - extensions_list := extend(extensions_list, client_hello_extensions)
    transitions:
      - target: START.DHE
        condition: configuration.dhe_enabled = True
      - target: START.PSK
        condition: configuration.psk_enabled = True

  - name: START.PSK
    actions:
    transitions:
      - target: INVALID_CONFIGURATION
        condition: configuration.symmetric_key_identities.length = 0
      - target: INVALID_CONFIGURATION
        condition: configuration.psk_key_exchange_mode != "psk_dhe_ke" and configuration.psk_key_exchange_mode != "psk_ke"
      - target: START.PSK_EXTENSIONS

  - name: START.PSK_EXTENSIONS
    actions:
      - extensions_list := append(extensions_list, pre_shared_key_extension())  # FIXME: which input parameters are needed for pre_shared_key_extension?
      - extensions_list := append(extensions_list, psk_key_exchange_modes_extension(configuration))
    transitions:
      - target: START.DHE
        condition: configuration.psk_key_exchange_mode = "psk_dhe_ke"
      - target: START.SEND
        condition: configuration.psk_key_exchange_mode = "psk_ke"

  - name: START.DHE
    actions:
    transitions:
      - target: INVALID_CONFIGURATION
        condition: configuration.supported_groups.length = 0
      - target: INVALID_CONFIGURATION
        condition: configuration.signature_algorithms.length = 0
      - target: INVALID_CONFIGURATION
        condition: configuration.signature_algorithms_cert.length = 0
      - target: START.DHE_EXTENSIONS

  - name: START.DHE_EXTENSIONS
    actions:
      - extensions_list := append(extensions_list, supported_groups_extension(configuration))
      - extensions_list := append(extensions_list, key_share_extension(configuration))  # (EC)DHE share for some or all of supported groups
      - extensions_list := append(extensions_list, signature_algorithms_extension(configuration))
      - extensions_list := append(extensions_list, signature_algorithms_cert_extension(configuration))  # if configured
    transitions:
      - target: START.SEND

  - name: START.SEND
    actions:  # FIXME: continue revision
      - Read configuration.post_handshake_auth_enabled and add post_handshake_auth to extensions_list if enabled
      - ClientHello := ClientHello()
      - ClientHello.random := read(rng_in, 32)  # 32 bytes
      - Read list of supported symmetric cipher options from configuration and store list in ClientHello.cipher_suites
      - ClientHello.extensions := extensions_list
      - Send ClientHello to record_out
      - Update transcript_hash with ClientHello
      - Read early data configuration
    channels:
      - name: rng_in
        access: r
      - name: record_out
        access: w
    data:
      - name: configuration
        access: r
      - name: extensions_list
        access: rw
      - name: ClientHello
        access: w
      - name: transcript_hash
        access: w
    transitions:
      - target: WAIT_SH
        condition: early data not configured
      - target: START.READ_PSK_FOR_EARLY_DATA
        condition: early data configured

  - name: START.READ_PSK_FOR_EARLY_DATA
    actions:
      - Read PSK from keystore_in
      - early_secret := HKDF-Extract(0, PSK)
      - Erase PSK
      - client_early_traffic_secret := Derive-Secret(early_secret, "c e traffic", transcript_hash)
      - Send client_early_traffic_secret to record_out
      - Erase client_early_traffic_secret
    channels:
      - name: keystore_in
        access: r
      - name: record_out
        access: w
    data:
      - name: transcript_hash
        access: r
      - name: early_secret
        access: rw
      - name: client_early_traffic_secret
        access: rw
    transitions:
      - target: INVALID_CONFIGURATION
        condition: no valid PSK
      - target: WAIT_SH

  - name: WAIT_SH
    actions:
      - Read ServerHello form record_in
      - Update transcript_hash with ServerHello
      - Parse ServerHello
      - Check ServerHello.legacy_version = 0x0303
      - Check ServerHello.legacy_session_id_echo = 0
      - Check ServerHello.legacy_compression_method = 0
      - hash_length := ServerHello.cipher_suite.length
    channels:
      - name: record_in
        access: r
    data:
      - name: ServerHello
        access: rw
      - name: transcript_hash
        access: rw
      - name: hash_length
        access: w
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: parsing failed
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no ServerHello received
      - target: SEND_ALERT_PROTOCOL_VERSION
        condition: ServerHello.legacy_version != 0
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.legacy_session_id_echo != 0
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.legacy_compression_method != 0
      - target: WAIT_SH.VERIFY

  - name: WAIT_SH.VERIFY
    actions:
      - Check that ServerHello.cipher_suite is contained in ClientHello.cipher_suites
      - Check supported_versions in ServerHello.extensions
    data:
      - name: ServerHello
        access: r
      - name: ClientHello
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.cipher_suite was not proposed
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: supported_versions missing
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: supported_versions is not [0x0304]
      - target: WAIT_SH.CHECK_RETRY_REQUEST

  - name: WAIT_SH.CHECK_RETRY_REQUEST
    actions:
      - Check ServerHello.random
    data:
      - name: ServerHello
        access: r
      - name: retry_request_received
        access: r
    transitions:
      - target: WAIT_SH.PARSE_HRR
        condition: ServerHello.random matches special value for HelloRetryRequest and retry_request_received == False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: ServerHello.random matches special value for HelloRetryRequest and retry_request_received == True
      - target: WAIT_SH.EXTENSIONS

  - name: WAIT_SH.EXTENSIONS
    actions:
      - Check ServerHello.extensions does not contain any new extension compared to ClientHello.extensions
      - Read key exchange mode from configuration
    data:
      - name: ServerHello
        access: r
      - name: ClientHello
        access: r
      - name: configuration
        access: r
    transitions:
      - target: WAIT_SH.EXTENSIONS_PSK
        condition: PSK configured
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: DHE and not PSK configured

  - name: WAIT_SH.EXTENSIONS_PSK
    actions:
      - Check for pre_shared_key in ServerHello.extensions
      - Check selected_identity in pre_shared_key is in range of extensions_list['pre_shared_key']
      - Check ServerHello.cipher_suite indicates a Hash associated with the selected PSK (extensions_list['pre_shared_key'].OfferedPsks[selected_identity])
      - Read PSK key exchange mode from configuration
      - Check key_share not in ServerHello.extensions if PSK key exchange mode == psk_ke  # FIXME
      - Check for early_data in ServerHello.extensions
      - Check selected_identity == 0 if early_data present  # FIXME
    data:
      - name: ServerHello
        access: r
      - name: extensions_list
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: pre_shared_key not present
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: PSK key exchange mode == psk_dhe_ke
      - target: WAIT_EE
        condition: PSK key exchange mode == psk_ke
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share present in ServerHello.extensions and PSK key exchange mode == psk_ke
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: selected_identity in pre_shared_key is not in range
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.cipher_suite does not indicate a Hash associated with the selected PSK
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: selected_identity != 0 and early_data present

  - name: WAIT_SH.EXTENSIONS_DHE
    actions:
      - Check key_share in ServerHello.extensions contains one of key_share in extensions_list
    data:
      - name: ServerHello
        access: r
      - name: extensions_list
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share not present
      - target: WAIT_EE

  - name: WAIT_SH.PARSE_HRR
    actions:
      - retry_request_received := True
      - Check ServerHello.extensions does not contain any new extension compared to ClientHello.extensions except for cookie extension
      - If pre_shared_key exists in ServerHello.extensions, keep only keys associated with a hash in selected cipher suite
      - If key_share exists in ServerHello.extensions, check selected group corresponds to a group which was provided in supported_groups extension in ClientHello.extensions
      - If key_share exists in ServerHello.extensions, check selected group corresponds not to a group which was provided in key_share extension in ClientHello.extensions
      - If key_share exists in ServerHello.extensions, replace key_share in extensions_list with key_share containing single KeyShareEntry from indicated group
      - If cookie exists in ServerHello.extensions, add copy to extensions_list
      - If early_data exists in extension_list, remove it
      - If padding extension exists, optionall add, remove or change length
      - Replace transcript_hash with hash of synthetic Client Hello
      - Send ClientHello with updated extensions_list on record_out
      - Update transcript_hash with ServerHello
    channels:
      - name: record_out
        access: w
    data:
      - name: retry_request_received
        access: w
      - name: ServerHello
        access: r
      - name: extensions_list
        access: rw
      - name: ClientHello
        access: rw
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share in ServerHello.extensions exists and selected group corresponds not to a group which was provided in supported_groups extension in ClientHello.extensions
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share in ServerHello.extensions exists and selected group corresponds to a group which was provided in the key_share extension in ClientHello.extensions
      - target: WAIT_SH

  - name: WAIT_EE
    actions:
      - Calculate ecdh_key from ClientHello.key_share and ServerHello.key_share
      - derived_early_secret := Derive-Secret(early_secret, "derived", "")
      - Erase early_secret
      - handshake_secret := HKDF-Extract(derived_early_secret, ecdh_key)
      - Erase derived_early_secret
      - client_handshake_traffic_secret := Derive-Secret(handshake_secret, "c hs traffic", transcript_hash)
      - server_handshake_traffic_secret := Derive-Secret(handshake_secret, "s hs traffic", transcript_hash)
      - Send server_handshake_traffic_secret to record_out as client_write_key
      - Erase server_handshake_traffic_secret
      - derived_handshake_secret := Derive-Secret(handshake_secret, "derived", "")
      - Erase handshake_secret
      - Read EncryptedExtensions from record_in
    channels:
      - name: record_out
        access: w
      - name: record_in
        access: r
    data:
      - name: ClientHello
        access: r
      - name: ServerHello
        access: r
      - name: transcript_hash
        access: r
      - name: early_secret
        access: rw
      - name: client_handshake_traffic_secret
        access: w
      - name: derived_handshake_secret
        access: w
      - name: EncryptedExtensions
        access: w
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no EncryptedExtensions received
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE
    actions:
      - Parse extensions from EncryptedExtensions
      - Check next extensions, skip if unknown
    data:
      - name: EncryptedExtensions
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: forbidden extension (status_request, signature_algorithms, signed_certificate_timestamp, padding, key_share, pre_shared_key, psk_key_exchange_modes, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, signature_algorithms_cert) found
        # use_srtp is used to tunnel encrypted SRTP traffic without TLS encryption. As this would allow the application to send unencrypted traffic, we ignore it.
      - target: WAIT_EE.PARSE_SERVER_NAME
        condition: server_name extension found
      - target: WAIT_EE.PARSE_MAX_FRAGMENT_LENGTH
        condition: max_fragment_length extension found
      - target: WAIT_EE.PARSE_SUPPORTED_GROUPS
        condition: supported_groups extension found
      - target: WAIT_EE.PARSE_HEARTBEAT
        condition: heartbeat extension found
      - target: WAIT_EE.PARSE_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
        condition: application_layer_protocol_negotiation extension found
      - target: WAIT_EE.PARSE_CLIENT_CERTIFICATE_TYPE
        condition: client_certificate_type extension found
      - target: WAIT_EE.PARSE_SERVER_CERTIFICATE_TYPE
        condition: server_certificate_type extension found
      - target: WAIT_EE.PARSE_EARLY_DATA
        condition: early_data extension found
      - target: WAIT_EE.CHECK_EXTENSIONS
        condition: no further extensions

  - name: WAIT_EE.CHECK_EXTENSIONS
    actions:
      - Update transcript_hash with EncryptedExtensions
      - Check if configuration.server_name and server_name_received
      - Check if configuration.max_fragment_length and max_fragment_length_received
      - Check if configuration.early_data and early_data_received
    data:
      - name: EncryptedExtensions
        access: r
      - name: server_name_received
        access: r
      - name: max_fragment_length_received
        access: r
      - name: early_data_received
        access: r
      - name: configuration
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: configuration.server_name is set and server_name_received = False
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: configuration.max_fragment_length is set and max_fragment_length_received = False
      - target: NO_EARLY_DATA
        condition: configuration.early_data is set and early_data_received = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.DISPATCH
    actions:
      - Read configuration.key_exchange_mode
    data:
      - name: configuration
        access: r
    transitions:
      - target: WAIT_FINISHED
        condition: only PSK is used
      - target: WAIT_CERT_CR
        condition: certificates are used

  - name: WAIT_EE.PARSE_SERVER_NAME
    actions:
      - Read server name from EncryptedExtensions
      - Read configuration.server_name
      - Check if server name has empty extension_data
      - server_name_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: server_name
        access: rw
      - name: server_name_received
        access: w
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no server_name sent in ClientHello
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: server_name not empty
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_MAX_FRAGMENT_LENGTH
    actions:
      - Read max fragment length from EncryptedExtensions
      - Read configuration.max_fragment_length
      - Check if max fragment length matches configuration.max_fragment_length
      - max_fragment_length_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: max_fragment_length
        access: r
      - name: max_fragment_length
        access: w
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_SUPPORTED_GROUPS
    actions:
      - Read supported groups from EncryptedExtensions
      - Send supported groups to datastore_out
    channels:
      - name: datastore_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_HEARTBEAT
    actions:
      - Read heartbeat from EncryptedExtensions
      - Create HeartbeatControlMessage containing heartbeat mode and configuration.heartbeat
      - Send HeartbeatControlMessage to heartbeat_control_out
    channels:
      - name: heartbeat_control_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
    actions:
      - Read application_layer_protocol_negotiation from EncryptedExtensions
      - Check only one protocol selected
      - Check selected protocol is one of proposed protocols from configuration
      - Send selected protocol to application_out
    channels:
      - name: application_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: more than one or invalid protocol selected
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_CLIENT_CERTIFICATE_TYPE
    actions:
      - Read client_certificate_type from EncryptedExtensions
      - Check selected type is one of proposed types from configuration
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_UNSUPPORTED_CERTIFICATE
        condition: invalid certificate type
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_SERVER_CERTIFICATE_TYPE
    actions:
      - Read server_certificate_type from EncryptedExtensions
      - Check selected type is one of proposed types from configuration
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
      - name: server_certificate_type
        access: w
    transitions:
      - target: SEND_ALERT_UNSUPPORTED_CERTIFICATE
        condition: invalid certificate type
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_EARLY_DATA
    actions:
      - Read early_data from EncryptedExtensions
      - early_data_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: early_data_received
        access: w
    transitions:
      - target: WAIT_EE.PARSE

  - name: NO_EARLY_DATA
    actions:
      - Indicate no early data to application_out
    channels:
      - name: application_out
        access: w
    transitions:
      - target: WAIT_EE.DISPATCH

  - name: WAIT_CERT_CR
    actions:
      - Read CertificateCrMessage from record_in
    channels:
      - name: record_in
        access: r
    data:
      - name: CertificateCrMessage
        access: r
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no Certificate or CertificateRequest received
      - target: PARSE_CERT
        condition: Certificate received
      - target: PARSE_CR
        condition: CertificateRequest received

  - name: PARSE_CR
    actions:
      - certificate_request_received := True
      - CertificateRequest := CertificateCrMessage
      - Parse extensions from CertificateRequest
      - Check next extensions, skip if unknown  # FIXME: signed_certificate_timestamp not supported
    data:
      - name: CertificateCrMessage
        access: r
      - name: CertificateRequest
        access: rw
      - name: certificate_request_received
        access: w
    transitions:
      - target: PARSE_CR.PARSE_STATUS_REQUEST
        condition: status_request extension found
      - target: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: certificate_authorities extension found
      - target: PARSE_CR.PARSE_OID_FILTERS
        condition: oid_filters extension found
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: signature_algorithms extension found
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: signature_algorithms_cert extension found
      - target: PARSE_CR.CHECK_EXTENSIONS
        condition: no further extensions

  - name: PARSE_CR.PARSE_STATUS_REQUEST
    actions:
      - status_request_received := True
      - Store status_request
    data:
      - name: status_request_received
        access: w
      - name: status_request
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - certificate_authorities_received := True
      - Store certificate_authorities
    data:
      - name: certificate_authorities_received
        access: w
      - name: certificate_authorities
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_OID_FILTERS
    actions:
      - oid_filters_received := True
      - Store oid_filters
    data:
      - name: oid_filters_received
        access: w
      - name: oid_filters
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - signature_algorithms_received := True
      - Store signature_algorithms
    data:
      - name: signature_algorithms_received
        access: w
      - name: signature_algorithms
        access: w
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no supported signature algorithm
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - signature_algorithms_cert_received := True
      - Store signature_algorithms_cert
    data:
      - name: signature_algorithms_cert_received
        access: w
      - name: signature_algorithms_cert
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.CHECK_EXTENSIONS
    actions:
      - Update transcript_hash with CertificateRequest
      - Check if signature_algorithms_received = True
    data:
      - name: CertificateRequest
        access: r
      - name: signature_algorithms_received
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: signature_algorithms_received = False
      - target: WAIT_CERT

  - name: WAIT_CERT
    actions:
      - Read CertificateCrMessage from record_in
    channels:
      - name: record_in
        access: r
    data:
      - name: CertificateCrMessage
        access: w
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no Certificate received
      - target: SEND_ALERT_DECODE_ERROR
        condition: Certificate empty
      - target: PARSE_CERT
        condition: Certificate received

  - name: PARSE_CERT
    actions:
      - Certificate := CertificateCrMessage
      - Update transcript_hash with Certificate
      - Check Certificate.certificate_list using server_certificate_type
    data:
      - name: CertificateCrMessage
        access: r
      - name: Certificate
        access: rw
      - name: server_certificate_type
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: CertificateRequest.certificate_list is empty
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: server_certificate_type = RawPublicKey and CertificateRequest.certificate_list does not contain exactly one entry
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: server_certificate_type != X509 and server_certificate_type != RawPublicKey
      - target: PARSE_CERT.PARSE_ENTRIES

  - name: PARSE_CERT.PARSE_ENTRIES
    actions:
      - Parse CertificateEntry from CertificateRequest
      - Store CertificateEntry in CertificateList
      - Check next entry
    data:
      - name: CertificateRequest
        access: r
      - name: CertificateEntry
        access: w
      - name: CertificateList
        access: w
    transitions:
      - target: PARSE_CERT.VERIFY_CERTIFICATE
        condition: no further entries
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.PARSE_EXTENSIONS
    actions:
      - Parse CertificateEntry.extensions
      - Check next extensions, skip if unknown  # FIXME: signed_certificate_timestamp not supported
    data:
      - name: CertificateEntry
        access: r
      - name: configuration
        access: r
    transitions:
      - target: PARSE_CERT.PARSE_STATUS_REQUEST
        condition: status_request extension found and was requested by configuration.status_request
      - target: PARSE_CERT.PARSE_ENTRIES
        condition: no further extensions

  - name: PARSE_CERT.PARSE_STATUS_REQUEST
    actions:
      - Read and verify CertificateStatus from CertificateEntry.extensions
    data:
      - name: CertificateEntry
        access: r
    transitions:
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.VERIFY_CERTIFICATE
    actions:
      - Verify certificates and their status in CertificateList
    data:
      - name: CertificateList
        access: r
    transitions:
      - target: WAIT_CV
        condition: certificate valid
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: invalid certificate
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: Certificate uses MD5 or is invalid

  - name: WAIT_CV
    actions:
      - Read CertificateVerify from record_in
      - Ensure CertificateVerify.algorithm is one of configuration.signature_algorithms
      - Ensure CertificateVerify.algorithm is compatible to signature algorithm in Certificate
      - Ensure RSA signatures use an RSASSA-PSS algorithm
      - Ensure SHA-1 is not used
      - Verify CertificateVerify.signature using transcript_hash and public key of Certificate using CertificateVerify.algorithm
      - Update transcript_hash with CertificateVerify
    channels:
      - name: record_in
        access: r
    data:
      - name: Certificate
        access: r
      - name: CertificateVerify
        access: rw
      - name: transcript_hash
        access: rw
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: other message than CertificateVerify received
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: invalid algorithm
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: signature invalid
      - target: WAIT_FINISHED

  - name: WAIT_FINISHED
    actions:
      - Read Finished from record_in
      - finished_key := HKDF-Expand-Label(client_handshake_traffic_secret, "finished", "", hash_length)
      - verify_data := HMAC(finished_key, transcript_hash)
      - Check Finished.verify_data = verify_data
      - Update transcript_hash with Finished
      - master_secret := HKDF-Extract(derived_handshake_secret, 0)
      - Erase derived_handshake_secret
      - client_application_traffic_secret := Derive-Secret(master_secret, "c ap traffic", transcript_hash)
      - server_application_traffic_secret := Derive-Secret(master_secret, "s ap traffic", transcript_hash)
      - resumption_master_secret := Derive-Secret(master_secret, "res master", transcript_hash)
      - Erase master_secret
    channels:
      - name: record_in
        access: r
    data:
      - name: client_handshake_traffic_secret
        access: r
      - name: finished_key
        access: w
      - name: transcript_hash
        access: r
      - name: derived_handshake_secret
        access: rw
      - name: client_application_traffic_secret
        access: w
      - name: server_application_traffic_secret
        access: w
      - name: resumption_master_secret
        access: w
      - name: hash_length
        access: r
    transitions:
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: Finished invalid
      - target: SEND_END_OF_EARLY_DATA
        condition: early_data_received = True
      - target: CHECK_CERTIFICATE_CONDITIONS
        condition: early_data_received = False

  - name: SEND_END_OF_EARLY_DATA
    actions:
      - Send EndOfEarlyData to record_out
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CHECK_CERTIFICATE_CONDITIONS

  - name: CHECK_CERTIFICATE_CONDITIONS
    actions:
      - Check certificate_request_received
      - Read available certificates from configuration
      - Filter certificates compatible with certificate_authorities if certificate_authorities_received
      - Filter certificates compatible with oid_filters if oid_filters_received
      - Filter certificates compatible with signature_algorithms if signature_algorithms_received and not signature_algorithms_cert_received
      - Filter certificates compatible with signature_algorithms_cert if signature_algorithms_cert_received
    data:
      - name: certificate_request_received
        access: r
      - name: configuration
        access: r
      - name: certificates
        access: rw
      - name: certificate_authorities
        access: r
      - name: certificate_authorities_received
        access: r
      - name: oid_filters
        access: r
      - name: oid_filters_received
        access: r
      - name: signature_algorithms
        access: r
      - name: signature_algorithms_received
        access: r
      - name: signature_algorithms_cert
        access: r
      - name: signature_algorithms_cert_received
        access: r
    transitions:
      - target: SEND_FINISHED
        name: certificate_request_received = False
      - target: SEND_CERTIFICATE
        condition: certificate_request_received = True and certificates is non-empty
      - target: SEND_EMPTY_CERTIFICATE
        condition: certificate_request_received = True and certificates is empty

  - name: SEND_CERTIFICATE
    actions:
      - Do OCSP request based on selected certificate and status_request if status_request_received
      - Create Certificate using configuration
      - Send Certificate to record_out
      - Update transcript_hash with Certificate
    channels:
      - name: record_out
        access: w
    data:
      - name: certificates
        access: rw
      - name: Certificate
        access: w
      - name: configuration
        access: r
      - name: status_request
        access: r
      - name: status_request_received
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_CERTIFICATE_VERIFY

  - name: SEND_EMPTY_CERTIFICATE
    actions:
      - Create empty Certificate
      - Send Certificate to record_out
      - Update transcript_hash with Certificate
    channels:
      - name: record_out
        access: w
    data:
      - name: Certificate
        access: w
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_FINISHED

  - name: SEND_CERTIFICATE_VERIFY
    actions:
      - Select one algorithm of signature_algorithms
      - Create CertificateVerify with transcript_hash using selected algorithm
      - Send CertificateVerify to record_out
      - Update transcript_hash with CertificateVerify
    channels:
      - name: record_out
        access: w
    data:
      - name: signature_algorithms
        access: r
      - name: CertificateVerify
        access: rw
      - name: transcript_hash
        access: r
    transitions:
      - target: SEND_FINISHED

  - name: SEND_FINISHED
    actions:
      - record_out := send(client_handshake_traffic_secret, "server_write_key")
      - Send client_handshake_traffic_secret to record_out as server_write_key
      - Erase client_handshake_traffic_secret
      - verify_data := HMAC(finished_key, transcript_hash)
      - Erase finished_key
      - Create Finished with verify_data
      - Send Finished to record_out
      - Send client_application_traffic_secret to record_out as client_write_key
      - Send server_application_traffic_secret to record_out as server_write_key
      - Erase server_application_traffic_secret
    channels:
      - name: record_out
        access: w
    data:
      - name: finished_key
        access: rw
      - name: transcript_hash
        access: r
      - name: client_application_traffic_secret
        access: rw
      - name: server_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED

# FIXME: send KeyUpdate (periodically) based on configuration
  - name: CONNECTED
    actions:
      - PostHandshakeMessage := read(record_in)
    transitions:
      - target: CONNECTED.NEW_SESSION_TICKET
        condition: PostHandshakeMessage.Tag = "NewSessionTicket"
      - target: CONNECTED.POST_HANDSHAKE_AUTH
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and configuration.post_handshake_auth_enabled = True
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag = "CertificateRequest" and configuration.post_handshake_auth_enabled = False
      - target: CONNECTED.KEY_UPDATE
        condition: PostHandshakeMessage.Tag = "KeyUpdate"
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: PostHandshakeMessage.Tag != "NewSessionTicket" and PostHandshakeMessage.Tag != "CertificateRequest" and PostHandshakeMessage.Tag != "KeyUpdate"

  - name: CONNECTED.NEW_SESSION_TICKET
    actions:
      - NewSessionTicket := PostHandshakeMessage
      - psk := HKDF-Expand-Label(resumption_master_secret, "resumption", NewSessionTicket.ticket_nonce, hash_length)
      - keystore_out := send(psk, NewSessionTicket)
    channels:
      - name: keystore_out
        access: w
    data:
      - name: PostHandshakeMessage
        access: r
      - name: NewSessionTicket
        access: rw
      - name: resumption_master_secret
        access: r
      - name: hash_length
        access: r
    transitions:
      - target: CONNECTED

  - name: CONNECTED.POST_HANDSHAKE_AUTH
    actions:
      - PhaCertificateRequest := PostHandshakeMessage
      - pha_extension_position := 0
    data:
      - name: PostHandshakeMessage
        access: r
      - name: PhaCertificateRequest
        access: rw
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR
    actions:
      - pha_extension_type, pha_extension, pha_extension_position, pha_result := pha_parse_cr_extension(PhaCertificateRequest.extensions, pha_extension_position)
      # FIXME: signed_certificate_timestamp not supported
    transitions:
      - target: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
        condition: pha_extension_type = "status_request"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: pha_extension_type = "certificate_authorities"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
        condition: pha_extension_type = "oid_filters"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: pha_extension_type = "signature_algorithms"
      - target: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: pha_extension_type = "signature_algorithms_cert"
      - target: CONNECTED.PHA_PARSE_CR
        condition: pha_result = "unknown"
      - target: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
        condition: pha_result = "end"

  - name: CONNECTED.PHA_PARSE_CR.PARSE_STATUS_REQUEST
    actions:
      - pha_status_request_received := True
      - pha_status_request := pha_extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    actions:
      - pha_certificate_authorities_received := True
      - pha_certificate_authorities := pha_extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_OID_FILTERS
    actions:
      - pha_oid_filters_received := True
      - pha_oid_filters := pha_extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    actions:
      - pha_signature_algorithms_received := True
      - pha_signature_algorithms := pha_extension
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no supported signature algorithm
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    actions:
      - pha_signature_algorithms_cert_received := True
      - pha_signature_algorithms_cert := pha_extension
    transitions:
      - target: CONNECTED.PHA_PARSE_CR

  - name: CONNECTED.PHA_PARSE_CR.CHECK_EXTENSIONS
    actions:
      - pha_transcript_hash := transcript_hash
      - Update pha_transcript_hash with PhaCertificateRequest
      - Check if signature_algorithms_received = True
    data:
      - name: PhaCertificateRequest
        access: r
      - name: pha_signature_algorithms_received
        access: r
      - name: transcript_hash
        access: r
      - name: pha_transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: signature_algorithms_received = False
      - target: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS

  - name: CONNECTED.PHA_CHECK_CERTIFICATE_CONDITIONS
    actions:
      - Read available pha_certificates from configuration
      - Filter pha_certificates compatible with pha_certificate_authorities if pha_certificate_authorities_received
      - Filter pha_certificates compatible with pha_oid_filters if pha_oid_filters_received
      - Filter pha_certificates compatible with pha_signature_algorithms if pha_signature_algorithms_received and not signature_algorithms_cert_received
      - Filter pha_certificates compatible with pha_signature_algorithms_cert if pha_signature_algorithms_cert_received
    data:
      - name: configuration
        access: r
      - name: pha_certificates
        access: rw
      - name: pha_certificate_authorities
        access: r
      - name: pha_certificate_authorities_received
        access: r
      - name: pha_oid_filters
        access: r
      - name: pha_oid_filters_received
        access: r
      - name: pha_signature_algorithms
        access: r
      - name: pha_signature_algorithms_received
        access: r
      - name: pha_signature_algorithms_cert
        access: r
      - name: pha_signature_algorithms_cert_received
        access: r
    transitions:
      - target: CONNECTED.PHA_SEND_CERTIFICATE
        condition: pha_certificates is non-empty
      - target: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
        condition: pha_certificates is empty

  - name: CONNECTED.PHA_SEND_CERTIFICATE
    actions:
      - Do OCSP request based on selected certificate and pha_status_request if pha_status_request_received
      - Create PhaCertificate using configuration
      - Send PhaCertificate to record_out
    channels:
      - name: record_out
        access: w
    data:
      - name: pha_certificates
        access: rw
      - name: PhaCertificate
        access: rw
      - name: configuration
        access: r
      - name: pha_status_request
        access: r
      - name: pha_status_request_received
        access: r
    transitions:
      - target: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY

  - name: CONNECTED.PHA_SEND_EMPTY_CERTIFICATE
    actions:
      - Create empty PhaCertificate
      - Send PhaCertificate to record_out
    channels:
      - name: record_out
        access: w
    data:
      - name: PhaCertificate
        access: w
    transitions:
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_CERTIFICATE_VERIFY
    actions:
      - Select one algorithm of pha_signature_algorithms
      - Create PhaCertificateVerify with pha_transcript_hash using selected algorithm
      - Send PhaCertificateVerify to record_out
    channels:
      - name: record_out
        access: w
    data:
      - name: pha_signature_algorithms
        access: r
      - name: PhaCertificateVerify
        access: rw
      - name: pha_transcript_hash
        access: r
    transitions:
      - target: CONNECTED.PHA_SEND_FINISHED

  - name: CONNECTED.PHA_SEND_FINISHED
    actions:
      - finished_key := HKDF-Expand-Label(client_application_traffic_secret, "finished", "", hash_length)
      - verify_data := HMAC(finished_key, pha_transcript_hash)
      - Erase finished_key
      - Create Finished with verify_data
      - Send Finished to record_out
    channels:
      - name: record_out
        access: w
    data:
      - name: finished_key
        access: rw
      - name: pha_transcript_hash
        access: r
      - name: client_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED

  - name: CONNECTED.KEY_UPDATE
    actions:
      - KeyUpdate := PostHandshakeMessage
      - server_application_traffic_secret = HKDF-Expand-Label(server_application_traffic_secret, "traffic upd", "", hash_length)
      - Send server_application_traffic_secret to record_out as server_write_key
      - Check KeyUpdate.request_update
    channels:
      - name: record_out
        access: w
    data:
      - name: PostHandshakeMessage
        access: r
      - name: KeyUpdate
        access: rw
      - name: server_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED.SEND_KEY_UPDATE
        condition: KeyUpdate.request_update == update_requested
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: KeyUpdate.request_update invalid
      - target: CONNECTED

  - name: CONNECTED.SEND_KEY_UPDATE
    actions:
      - client_application_traffic_secret = HKDF-Expand-Label(client_application_traffic_secret, "traffic upd", "", hash_length)
      - Create and send KeyUpdate with request_update := update_not_requested to record_out
      - Send client_application_traffic_secret to record_out as client_write_key
    channels:
      - name: record_out
        access: w
    data:
      - name: KeyUpdate
        access: w
      - name: client_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED

  - name: SEND_ALERT_ILLEGAL_PARAMETER
    actions:
      - Send illegal_parameter alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECODE_ERROR
    actions:
      - Send decode_error alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_BAD_CERTIFICATE
    actions:
      - Send bad_certificate alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_UNEXPECTED_MESSAGE
    actions:
      - Send unexpected_message alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECRYPT_ERROR
    actions:
      - Send decrypt_error alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_PROTOCOL_VERSION
    actions:
      - Send protocol_version alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_MISSING_EXTENSION
    actions:
      - Send missing_extension alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_UNSUPPORTED_CERTIFICATE
    actions:
      - Send unsupported_certificate alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: CONNECTION_TERMINATED
    actions:
      - Inform client application
    channels:
      - name: application_out
        access: w
    transitions:
      - target: FINAL

  - name: INVALID_CONFIGURATION
    actions:
      - Inform client application
    channels:
      - name: application_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED
