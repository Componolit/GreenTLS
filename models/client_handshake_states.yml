initial: START
final: FINAL
# FIXME: "A peer which receives a handshake message in an unexpected order MUST abort the handshake with an "unexpected_message" alert."
# FIXME: "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake."
states:
  - name: START
    desc:
      - Set retry_request_received := False
      - Set certificate_request_received := False
      - Set server_name_received := False
      - Set max_fragment_length_received := False
      - Set early_data_received := False
      - Set status_request_received := False
      - Set certificate_authorities_received := False
      - Set oid_filters_received := False
      - Set signature_algorithms_received := False
      - Set signature_algorithms_cert_received := False
      - Set server_certificate_type := X509
      - Read configuration from datastore_in
      - Read server prefered groups from datastore_in
      - Select supported_groups from server prefered groups and configuration.supported_groups
      - Check for symmetric cipher options in configuration
      - Read configuration.key_exchange_mode
      - Initialize extensions_list with supported_versions = [0x0304]
      - Read configuration and create extensions for Client Hello (server_name, max_fragment_length, status_request, supported_groups, signature_algorithms, use_srtp, heartbeat, application_layer_protocol_negotiation, client_certificate_type, server_certificate_type, padding, key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, post_handshake_auth, signature_algorithms_cert)  # FIXME: signed_certificate_timestamp not supported
    channels:
      - name: datastore_in
        access: r
    data:
      - name: retry_request_received
        access: w
      - name: certificate_request_received
        access: w
      - name: server_name_received
        access: w
      - name: max_fragment_length_received
        access: w
      - name: early_data_received
        access: w
      - name: status_request_received
        access: w
      - name: certificate_authorities_received
        access: w
      - name: oid_filters_received
        access: w
      - name: signature_algorithms_received
        access: w
      - name: signature_algorithms_cert_received
        access: w
      - name: server_certificate_type
        access: w
      - name: configuration
        access: rw
      - name: extensions_list
        access: w
    transitions:
      - target: START.DHE
        condition: DHE configured
      - target: START.PSK
        condition: PSK configured
      - target: INVALID_CONFIGURATION
        condition: no valid exchange mode
      - target: INVALID_CONFIGURATION
        condition: no valid cipher suites

  - name: START.PSK
    desc:
      - Check for supported symmetric key identities and PSK key exchange modes from configuration
    data:
      - name: configuration
        access: r
    transitions:
      - target: INVALID_CONFIGURATION
        condition: no valid symmetric key identities
      - target: INVALID_CONFIGURATION
        condition: no valid PSK key exchange modes
      - target: START.PSK_EXTENSIONS

  - name: START.PSK_EXTENSIONS
    desc:
      - Read list of symmetric key identities from configuration
      - Add pre_shared_key to extensions_list
      - Read PSK key exchange modes from configuration
      - Add psk_key_exchange_modes to extensions_list
    data:
      - name: configuration
        access: r
      - name: extensions_list
        access: rw
    transitions:
      - target: START.DHE
        condition: PSK key exchange mode == psk_dhe_ke
      - target: START.SEND
        condition: PSK key exchange mode == psk_ke

  - name: START.DHE
    desc:
      - Check for supported (EC)DHE groups and shares, signature algorithms and signature algorithms for certificates from configuration
    data:
      - name: configuration
        access: r
    transitions:
      - target: INVALID_CONFIGURATION
        condition: no valid (EC)DHE groups and shares
      - target: INVALID_CONFIGURATION
        condition: no valid signature algorithms
      - target: START.DHE_EXTENSIONS
        condition: valid configuration

  - name: START.DHE_EXTENSIONS
    desc:
      - Read supported (EC)DHE groups and shares from configuration
      - Add supported_groups to extensions_list
      - Create (EC)DHE share for some or all of supported groups
      - Add key_share to extensions_list
      - Read supported signature algorithms from configuration
      - Add signature_algorithms to extensions_list
      - Read supported signature algorithms for certificates from configuration
      - Add signature_algorithms_cert to extensions_list  # if configured
    data:
      - name: configuration
        access: r
      - name: extensions_list
        access: rw
    transitions:
      - target: START.SEND

  - name: START.SEND
    desc:
      - Read configuration regarding post_handshake_auth and add post_handshake_auth to extensions_list if enabled
      - Create ClientHello message with default values
      - Read 32 bytes from rng_in and store in ClientHello.random
      - Read list of supported symmetric cipher options from configuration and store list in ClientHello.cipher_suites
      - Set ClientHello.extensions to extensions_list
      - Send ClientHello to record_out
      - Update transcript_hash with ClientHello
      - Read early data configuration
    channels:
      - name: rng_in
        access: r
      - name: record_out
        access: w
    data:
      - name: configuration
        access: r
      - name: extensions_list
        access: rw
      - name: ClientHello
        access: w
      - name: transcript_hash
        access: w
    transitions:
      - target: WAIT_SH
        condition: early data not configured
      - target: START.READ_PSK_FOR_EARLY_DATA
        condition: early data configured

  - name: START.READ_PSK_FOR_EARLY_DATA
    desc:
      - Read PSK from keystore_in
      - early_secret := HKDF-Extract(0, PSK)
      - Erase PSK
      - client_early_traffic_secret := Derive-Secret(early_secret, "c e traffic", transcript_hash)
      - Send client_early_traffic_secret to record_out
      - Erase client_early_traffic_secret
    channels:
      - name: keystore_in
        access: r
      - name: record_out
        access: w
    data:
      - name: transcript_hash
        access: r
      - name: early_secret
        access: rw
      - name: client_early_traffic_secret
        access: rw
    transitions:
      - target: INVALID_CONFIGURATION
        condition: no valid PSK
      - target: WAIT_SH

  - name: WAIT_SH
    desc:
      - Read ServerHello form record_in
      - Update transcript_hash with ServerHello
      - Parse ServerHello
      - Check ServerHello.legacy_version = 0x0303
      - Check ServerHello.legacy_session_id_echo = 0
      - Check ServerHello.legacy_compression_method = 0
      - Set hash_length := ServerHello.cipher_suite.length
    channels:
      - name: record_in
        access: r
    data:
      - name: ServerHello
        access: rw
      - name: transcript_hash
        access: rw
      - name: hash_length
        access: w
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: parsing failed
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no ServerHello received
      - target: SEND_ALERT_PROTOCOL_VERSION
        condition: ServerHello.legacy_version != 0
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.legacy_session_id_echo != 0
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.legacy_compression_method != 0
      - target: WAIT_SH.VERIFY

  - name: WAIT_SH.VERIFY
    desc:
      - Check that ServerHello.cipher_suite is contained in ClientHello.cipher_suites
      - Check supported_versions in ServerHello.extensions
    data:
      - name: ServerHello
        access: r
      - name: ClientHello
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.cipher_suite was not proposed
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: supported_versions missing
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: supported_versions is not [0x0304]
      - target: WAIT_SH.CHECK_RETRY_REQUEST

  - name: WAIT_SH.CHECK_RETRY_REQUEST
    desc:
      - Check ServerHello.random
    data:
      - name: ServerHello
        access: r
      - name: retry_request_received
        access: r
    transitions:
      - target: WAIT_SH.PARSE_HRR
        condition: ServerHello.random matches special value for HelloRetryRequest and retry_request_received == False
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: ServerHello.random matches special value for HelloRetryRequest and retry_request_received == True
      - target: WAIT_SH.EXTENSIONS

  - name: WAIT_SH.EXTENSIONS
    desc:
      - Check ServerHello.extensions does not contain any new extension compared to ClientHello.extensions
      - Read key exchange mode from configuration
    data:
      - name: ServerHello
        access: r
      - name: ClientHello
        access: r
      - name: configuration
        access: r
    transitions:
      - target: WAIT_SH.EXTENSIONS_PSK
        condition: PSK configured
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: DHE and not PSK configured

  - name: WAIT_SH.EXTENSIONS_PSK
    desc:
      - Check for pre_shared_key in ServerHello.extensions
      - Check selected_identity in pre_shared_key is in range of extensions_list['pre_shared_key']
      - Check ServerHello.cipher_suite indicates a Hash associated with the selected PSK (extensions_list['pre_shared_key'].OfferedPsks[selected_identity])
      - Read PSK key exchange mode from configuration
      - Check key_share not in ServerHello.extensions if PSK key exchange mode == psk_ke  # FIXME
      - Check for early_data in ServerHello.extensions
      - Check selected_identity == 0 if early_data present  # FIXME
    data:
      - name: ServerHello
        access: r
      - name: extensions_list
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: pre_shared_key not present
      - target: WAIT_SH.EXTENSIONS_DHE
        condition: PSK key exchange mode == psk_dhe_ke
      - target: WAIT_EE
        condition: PSK key exchange mode == psk_ke
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share present in ServerHello.extensions and PSK key exchange mode == psk_ke
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: selected_identity in pre_shared_key is not in range
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: ServerHello.cipher_suite does not indicate a Hash associated with the selected PSK
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: selected_identity != 0 and early_data present

  - name: WAIT_SH.EXTENSIONS_DHE
    desc:
      - Check key_share in ServerHello.extensions contains one of key_share in extensions_list
    data:
      - name: ServerHello
        access: r
      - name: extensions_list
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share not present
      - target: WAIT_EE

  - name: WAIT_SH.PARSE_HRR
    desc:
      - Set retry_request_received := True
      - Check ServerHello.extensions does not contain any new extension compared to ClientHello.extensions except for cookie extension
      - If pre_shared_key exists in ServerHello.extensions, keep only keys associated with a hash in selected cipher suite
      - If key_share exists in ServerHello.extensions, check selected group corresponds to a group which was provided in supported_groups extension in ClientHello.extensions
      - If key_share exists in ServerHello.extensions, check selected group corresponds not to a group which was provided in key_share extension in ClientHello.extensions
      - If key_share exists in ServerHello.extensions, replace key_share in extensions_list with key_share containing single KeyShareEntry from indicated group
      - If cookie exists in ServerHello.extensions, add copy to extensions_list
      - If early_data exists in extension_list, remove it
      - If padding extension exists, optionall add, remove or change length
      - Replace transcript_hash with hash of synthetic Client Hello
      - Send ClientHello with updated extensions_list on record_out
      - Update transcript_hash with ServerHello
    channels:
      - name: record_out
        access: w
    data:
      - name: retry_request_received
        access: w
      - name: ServerHello
        access: r
      - name: extensions_list
        access: rw
      - name: ClientHello
        access: rw
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share in ServerHello.extensions exists and selected group corresponds not to a group which was provided in supported_groups extension in ClientHello.extensions
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: key_share in ServerHello.extensions exists and selected group corresponds to a group which was provided in the key_share extension in ClientHello.extensions
      - target: WAIT_SH

  - name: WAIT_EE
    desc:
      - Calculate ecdh_key from ClientHello.key_share and ServerHello.key_share
      - derived_early_secret := Derive-Secret(early_secret, "derived", "")
      - Erase early_secret
      - handshake_secret := HKDF-Extract(derived_early_secret, ecdh_key)
      - Erase derived_early_secret
      - client_handshake_traffic_secret := Derive-Secret(handshake_secret, "c hs traffic", transcript_hash)
      - server_handshake_traffic_secret := Derive-Secret(handshake_secret, "s hs traffic", transcript_hash)
      - Send server_handshake_traffic_secret to record_out as client_write_key
      - Erase server_handshake_traffic_secret
      - derived_handshake_secret := Derive-Secret(handshake_secret, "derived", "")
      - Erase handshake_secret
      - Read EncryptedExtensions from record_in
    channels:
      - name: record_out
        access: w
      - name: record_in
        access: r
    data:
      - name: ClientHello
        access: r
      - name: ServerHello
        access: r
      - name: transcript_hash
        access: r
      - name: early_secret
        access: rw
      - name: client_handshake_traffic_secret
        access: w
      - name: derived_handshake_secret
        access: w
      - name: EncryptedExtensions
        access: w
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no EncryptedExtensions received
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE
    desc:
      - Parse extensions from EncryptedExtensions
      - Check next extensions, skip if unknown
    data:
      - name: EncryptedExtensions
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: forbidden extension (status_request, signature_algorithms, signed_certificate_timestamp, padding, key_share, pre_shared_key, psk_key_exchange_modes, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, signature_algorithms_cert) found
        # use_srtp is used to tunnel encrypted SRTP traffic without TLS encryption. As this would allow the application to send unencrypted traffic, we ignore it.
      - target: WAIT_EE.PARSE_SERVER_NAME
        condition: server_name extension found
      - target: WAIT_EE.PARSE_MAX_FRAGMENT_LENGTH
        condition: max_fragment_length extension found
      - target: WAIT_EE.PARSE_SUPPORTED_GROUPS
        condition: supported_groups extension found
      - target: WAIT_EE.PARSE_HEARTBEAT
        condition: heartbeat extension found
      - target: WAIT_EE.PARSE_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
        condition: application_layer_protocol_negotiation extension found
      - target: WAIT_EE.PARSE_CLIENT_CERTIFICATE_TYPE
        condition: client_certificate_type extension found
      - target: WAIT_EE.PARSE_SERVER_CERTIFICATE_TYPE
        condition: server_certificate_type extension found
      - target: WAIT_EE.PARSE_EARLY_DATA
        condition: early_data extension found
      - target: WAIT_EE.CHECK_EXTENSIONS
        condition: no further extensions

  - name: WAIT_EE.CHECK_EXTENSIONS
    desc:
      - Update transcript_hash with EncryptedExtensions
      - Check if configuration.server_name and server_name_received
      - Check if configuration.max_fragment_length and max_fragment_length_received
      - Check if configuration.early_data and early_data_received
    data:
      - name: EncryptedExtensions
        access: r
      - name: server_name_received
        access: r
      - name: max_fragment_length_received
        access: r
      - name: early_data_received
        access: r
      - name: configuration
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: configuration.server_name is set and server_name_received = False
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: configuration.max_fragment_length is set and max_fragment_length_received = False
      - target: NO_EARLY_DATA
        condition: configuration.early_data is set and early_data_received = False
      - target: WAIT_EE.DISPATCH

  - name: WAIT_EE.DISPATCH
    desc:
      - Read configuration.key_exchange_mode
    data:
      - name: configuration
        access: r
    transitions:
      - target: WAIT_FINISHED
        condition: only PSK is used
      - target: WAIT_CERT_CR
        condition: certificates are used

  - name: WAIT_EE.PARSE_SERVER_NAME
    desc:
      - Read server name from EncryptedExtensions
      - Read configuration.server_name
      - Check if server name has empty extension_data
      - Set server_name_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: server_name
        access: rw
      - name: server_name_received
        access: w
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no server_name sent in ClientHello
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: server_name not empty
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_MAX_FRAGMENT_LENGTH
    desc:
      - Read max fragment length from EncryptedExtensions
      - Read configuration.max_fragment_length
      - Check if max fragment length matches configuration.max_fragment_length
      - Set max_fragment_length_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: max_fragment_length
        access: r
      - name: max_fragment_length
        access: w
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_SUPPORTED_GROUPS
    desc:
      - Read supported groups from EncryptedExtensions
      - Send supported groups to datastore_out
    channels:
      - name: datastore_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_HEARTBEAT
    desc:
      - Read heartbeat from EncryptedExtensions
      - Create HeartbeatControlMessage containing heartbeat mode and configuration.heartbeat
      - Send HeartbeatControlMessage to heartbeat_control_out
    channels:
      - name: heartbeat_control_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
    desc:
      - Read application_layer_protocol_negotiation from EncryptedExtensions
      - Check only one protocol selected
      - Check selected protocol is one of proposed protocols from configuration
      - Send selected protocol to application_out
    channels:
      - name: application_out
        access: w
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: more than one or invalid protocol selected
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_CLIENT_CERTIFICATE_TYPE
    desc:
      - Read client_certificate_type from EncryptedExtensions
      - Check selected type is one of proposed types from configuration
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_UNSUPPORTED_CERTIFICATE
        condition: invalid certificate type
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_SERVER_CERTIFICATE_TYPE
    desc:
      - Read server_certificate_type from EncryptedExtensions
      - Check selected type is one of proposed types from configuration
    data:
      - name: EncryptedExtensions
        access: r
      - name: configuration
        access: r
      - name: server_certificate_type
        access: w
    transitions:
      - target: SEND_ALERT_UNSUPPORTED_CERTIFICATE
        condition: invalid certificate type
      - target: WAIT_EE.PARSE

  - name: WAIT_EE.PARSE_EARLY_DATA
    desc:
      - Read early_data from EncryptedExtensions
      - Set early_data_received := True
    data:
      - name: EncryptedExtensions
        access: r
      - name: early_data_received
        access: w
    transitions:
      - target: WAIT_EE.PARSE

  - name: NO_EARLY_DATA
    desc:
      - Indicate no early data to application_out
    channels:
      - name: application_out
        access: w
    transitions:
      - target: WAIT_EE.DISPATCH

  - name: WAIT_CERT_CR
    desc:
      - Read CertificateCrMessage from record_in
    channels:
      - name: record_in
        access: r
    data:
      - name: CertificateCrMessage
        access: r
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no Certificate or CertificateRequest received
      - target: PARSE_CERT
        condition: Certificate received
      - target: PARSE_CR
        condition: CertificateRequest received

  - name: PARSE_CR
    desc:
      - Set certificate_request_received := True
      - Copy CertificateCrMessage to CertificateRequest
      - Parse extensions from CertificateRequest
      - Check next extensions, skip if unknown  # FIXME: signed_certificate_timestamp not supported
    data:
      - name: CertificateCrMessage
        access: r
      - name: CertificateRequest
        access: rw
      - name: transcript_hash
        access: rw
      - name: certificate_request_received
        access: w
    transitions:
      - target: PARSE_CR.PARSE_STATUS_REQUEST
        condition: status_request extension found
      - target: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
        condition: certificate_authorities extension found
      - target: PARSE_CR.PARSE_OID_FILTERS
        condition: oid_filters extension found
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
        condition: signature_algorithms extension found
      - target: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
        condition: signature_algorithms_cert extension found
      - target: PARSE_CR.CHECK_EXTENSIONS
        condition: no further extensions

  - name: PARSE_CR.PARSE_STATUS_REQUEST
    desc:
      - Set status_request_received := True
      - Store status_request
    data:
      - name: status_request_received
        access: w
      - name: status_request
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_CERTIFICATE_AUTHORITIES
    desc:
      - Set certificate_authorities_received := True
      - Store certificate_authorities
    data:
      - name: certificate_authorities_received
        access: w
      - name: certificate_authorities
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_OID_FILTERS
    desc:
      - Set oid_filters_received := True
      - Store oid_filters
    data:
      - name: oid_filters_received
        access: w
      - name: oid_filters
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS
    desc:
      - Set signature_algorithms_received := True
      - Store signature_algorithms
    data:
      - name: signature_algorithms_received
        access: w
      - name: signature_algorithms
        access: w
    transitions:
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: no supported signature algorithm
      - target: PARSE_CR

  - name: PARSE_CR.PARSE_SIGNATURE_ALGORITHMS_CERT
    desc:
      - Set signature_algorithms_cert_received := True
      - Store signature_algorithms_cert
    data:
      - name: signature_algorithms_cert_received
        access: w
      - name: signature_algorithms_cert
        access: w
    transitions:
      - target: PARSE_CR

  - name: PARSE_CR.CHECK_EXTENSIONS
    desc:
      - Update transcript_hash with CertificateRequest
      - Check if signature_algorithms_received = True
    data:
      - name: CertificateRequest
        access: r
      - name: signature_algorithms_received
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_MISSING_EXTENSION
        condition: signature_algorithms_received = False
      - target: WAIT_CERT

  - name: WAIT_CERT
    desc:
      - Read CertificateCrMessage from record_in
    channels:
      - name: record_in
        access: r
    data:
      - name: CertificateCrMessage
        access: w
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: no Certificate received
      - target: SEND_ALERT_DECODE_ERROR
        condition: Certificate empty
      - target: PARSE_CERT
        condition: Certificate received

  - name: PARSE_CERT
    desc:
      - Copy CertificateCrMessage to Certificate
      - Update transcript_hash with Certificate
      - Check Certificate.certificate_list using server_certificate_type
    data:
      - name: CertificateCrMessage
        access: r
      - name: Certificate
        access: rw
      - name: server_certificate_type
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_ALERT_DECODE_ERROR
        condition: CertificateRequest.certificate_list is empty
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: server_certificate_type = RawPublicKey and CertificateRequest.certificate_list does not contain exactly one entry
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: server_certificate_type != X509 and server_certificate_type != RawPublicKey
      - target: PARSE_CERT.PARSE_ENTRIES

  - name: PARSE_CERT.PARSE_ENTRIES
    desc:
      - Parse CertificateEntry from CertificateRequest
      - Store CertificateEntry in CertificateList
      - Check next entry
    data:
      - name: CertificateRequest
        access: r
      - name: CertificateEntry
        access: w
      - name: CertificateList
        access: w
    transitions:
      - target: PARSE_CERT.VERIFY_CERTIFICATE
        condition: no further entries
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.PARSE_EXTENSIONS
    desc:
      - Parse CertificateEntry.extensions
      - Check next extensions, skip if unknown  # FIXME: signed_certificate_timestamp not supported
    data:
      - name: CertificateEntry
        access: r
      - name: configuration
        access: r
    transitions:
      - target: PARSE_CERT.PARSE_STATUS_REQUEST
        condition: status_request extension found and was requested by configuration.status_request
      - target: PARSE_CERT.PARSE_ENTRIES
        condition: no further extensions

  - name: PARSE_CERT.PARSE_STATUS_REQUEST
    desc:
      - Read and verify CertificateStatus from CertificateEntry.extensions
    data:
      - name: CertificateEntry
        access: r
    transitions:
      - target: PARSE_CERT.PARSE_EXTENSIONS

  - name: PARSE_CERT.VERIFY_CERTIFICATE
    desc:
      - Verify certificates and their status in CertificateList
    data:
      - name: CertificateList
        access: r
    transitions:
      - target: WAIT_CV
        condition: certificate valid
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: invalid certificate
      - target: SEND_ALERT_BAD_CERTIFICATE
        condition: Certificate uses MD5 or is invalid

  - name: WAIT_CV
    desc:
      - Read CertificateVerify from record_in
      - Ensure CertificateVerify.algorithm is one of configuration.signature_algorithms
      - Ensure CertificateVerify.algorithm is compatible to signature algorithm in Certificate
      - Ensure RSA signatures use an RSASSA-PSS algorithm
      - Ensure SHA-1 is not used
      - Verify CertificateVerify.signature using transcript_hash and public key of Certificate using CertificateVerify.algorithm
      - Update transcript_hash with CertificateVerify
    channels:
      - name: record_in
        access: r
    data:
      - name: Certificate
        access: r
      - name: CertificateVerify
        access: rw
      - name: transcript_hash
        access: rw
      - name: configuration
        access: r
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: other message than CertificateVerify received
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: invalid algorithm
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: signature invalid
      - target: WAIT_FINISHED

  - name: WAIT_FINISHED
    desc:
      - Read Finished from record_in
      - finished_key := HKDF-Expand-Label(client_handshake_traffic_secret, "finished", "", hash_length)
      - verify_data := HMAC(finished_key, transcript_hash)
      - Check Finished.verify_data = verify_data
      - Update transcript_hash with Finished
      - master_secret := HKDF-Extract(derived_handshake_secret, 0)
      - Erase derived_handshake_secret
      - client_application_traffic_secret := Derive-Secret(master_secret, "c ap traffic", transcript_hash)
      - server_application_traffic_secret := Derive-Secret(master_secret, "s ap traffic", transcript_hash)
      - resumption_master_secret := Derive-Secret(master_secret, "res master", transcript_hash)
      - Erase master_secret
    channels:
      - name: record_in
        access: r
    data:
      - name: client_handshake_traffic_secret
        access: r
      - name: finished_key
        access: w
      - name: transcript_hash
        access: r
      - name: client_application_traffic_secret
        access: w
      - name: server_application_traffic_secret
        access: w
      - name: resumption_master_secret
        access: w
      - name: hash_length
        access: r
    transitions:
      - target: SEND_ALERT_DECRYPT_ERROR
        condition: Finished invalid
      - target: SEND_END_OF_EARLY_DATA
        condition: early_data_received = True
      - target: CHECK_CERTIFICATE_CONDITIONS
        condition: early_data_received = False

  - name: SEND_END_OF_EARLY_DATA
    desc:
      - Send EndOfEarlyData to record_out
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CHECK_CERTIFICATE_CONDITIONS

  - name: CHECK_CERTIFICATE_CONDITIONS
    desc:
      - Check certificate_request_received
      - Read available certificates from configuration
      - Filter certificates compatible with certificate_authorities if certificate_authorities_received
      - Filter certificates compatible with oid_filters if oid_filters_received
      - Filter certificates compatible with signature_algorithms if signature_algorithms_received and not signature_algorithms_cert_received
      - Filter certificates compatible with signature_algorithms_cert if signature_algorithms_cert_received
    data:
      - name: certificate_request_received
        access: r
      - name: configuration
        access: r
      - name: certificates
        access: rw
      - name: certificate_authorities
        access: r
      - name: certificate_authorities_received
        access: r
      - name: oid_filters
        access: r
      - name: oid_filters_received
        access: r
      - name: signature_algorithms
        access: r
      - name: signature_algorithms_received
        access: r
      - name: signature_algorithms_cert
        access: r
      - name: signature_algorithms_cert_received
        access: r
    transitions:
      - target: SEND_FINISHED
        name: certificate_request_received = False
      - target: SEND_CERTIFICATE
        condition: certificate_request_received = True and certificates is non-empty
      - target: SEND_EMPTY_CERTIFICATE
        condition: certificate_request_received = True and certificates is empty

  - name: SEND_CERTIFICATE
    desc:
      - Do OCSP request based on selected certificate and status_request if status_request_received
      - Create Certificate using configuration
      - Send Certificate to record_out
      - Update transcript_hash with Certificate
    channels:
      - name: record_out
        access: w
    data:
      - name: certificates
        access: rw
      - name: Certificate
        access: w
      - name: configuration
        access: r
      - name: status_request
        access: r
      - name: status_request_received
        access: r
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_CERTIFICATE_VERIFY

  - name: SEND_EMPTY_CERTIFICATE
    desc:
      - Create empty Certificate
      - Send Certificate to record_out
      - Update transcript_hash with Certificate
    channels:
      - name: record_out
        access: w
    data:
      - name: Certificate
        access: w
      - name: transcript_hash
        access: rw
    transitions:
      - target: SEND_FINISHED

  - name: SEND_CERTIFICATE_VERIFY
    desc:
      - Select one algorithm of signature_algorithms
      - Create CertificateVerify with transcript_hash using selected algorithm
      - Send CertificateVerify to record_out
      - Update transcript_hash with CertificateVerify
    data:
      - name: signature_algorithms
        access: r
      - name: CertificateVerify
        access: rw
      - name: transcript_hash
        access: r
    transitions:
      - target: SEND_FINISHED

  - name: SEND_FINISHED
    desc:
      - Send client_handshake_traffic_secret to record_out as server_write_key
      - Erase client_handshake_traffic_secret
      - verify_data := HMAC(finished_key, transcript_hash)
      - Erase finished_key
      - Create Finished with verify_data
      - Send Finished to record_out
      - Send client_application_traffic_secret to record_out as client_write_key
      - Erase client_application_traffic_secret
      - Send server_application_traffic_secret to record_out as server_write_key
      - Erase server_application_traffic_secret
    channels:
      - name: record_out
        access: w
      - name: finished_key
        access: rw
      - name: transcript_hash
        access: r
      - name: derived_handshake_secret
        access: rw
      - name: client_application_traffic_secret
        access: rw
      - name: server_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED

# FIXME: send KeyUpdate (periodically) based on configuration
  - name: CONNECTED
    desc:
      - Read PostHandshakeMessage from record_in
    channels:
      - name: record_in
        access: r
    data:
      - name: PostHandshakeMessage
        access: w
    transitions:
      - target: CONNECTED.NST
        condition: NewSessionTicket received
      - target: CONNECTED.PHA
        condition: CertificateRequest received
      - target: CONNECTED.KEY_UPDATE
        condition: KeyUpdate received
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: unexpected message received

  - name: CONNECTED.NST
    desc:
      - Copy PostHandshakeMessage to NewSessionTicket
      - psk := HKDF-Expand-Label(resumption_master_secret, "resumption", NewSessionTicket.ticket_nonce, hash_length)
      - Store psk and NewSessionTicket to keystore_out
    channels:
      - name: keystore_out
        access: w
    data:
      - name: PostHandshakeMessage
        access: r
      - name: NewSessionTicket
        access: rw
      - name: resumption_master_secret
        access: r
      - name: hash_length
        access: r
    transitions:
      - target: CONNECTED

  - name: CONNECTED.PHA
    desc:
      - Copy PostHandshakeMessage to CertificateRequest
      - Read configuration regarding post_handshake_auth
    data:
      - name: PostHandshakeMessage
        access: r
      - name: CertificateRequest
        access: rw
    transitions:
      - target: SEND_ALERT_UNEXPECTED_MESSAGE
        condition: post_handshake_auth not enabled
      - target: CONNECTED.PHA_2

  - name: CONNECTED.PHA_2
    desc:
      - Create and send Certificate, CertificateVerify (if Certificate non-empty), and Finished to record_out
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTED

  - name: CONNECTED.KEY_UPDATE
    desc:
      - Copy PostHandshakeMessage to KeyUpdate
      - server_application_traffic_secret = HKDF-Expand-Label(server_application_traffic_secret, "traffic upd", "", hash_length)
      - Send server_application_traffic_secret to record_out as server_write_key
      - Check KeyUpdate.request_update
    channels:
      - name: record_out
        access: w
    data:
      - name: PostHandshakeMessage
        access: r
      - name: KeyUpdate
        access: rw
      - name: server_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED.SEND_KEY_UPDATE
        condition: KeyUpdate.request_update == update_requested
      - target: SEND_ALERT_ILLEGAL_PARAMETER
        condition: KeyUpdate.request_update invalid
      - target: CONNECTED

  - name: CONNECTED.SEND_KEY_UPDATE
    desc:
      - client_application_traffic_secret = HKDF-Expand-Label(client_application_traffic_secret, "traffic upd", "", hash_length)
      - Create and send KeyUpdate with request_update := update_not_requested to record_out
      - Send client_application_traffic_secret to record_out as client_write_key
    channels:
      - name: record_out
        access: w
    data:
      - name: KeyUpdate
        access: w
      - name: client_application_traffic_secret
        access: rw
    transitions:
      - target: CONNECTED

  - name: SEND_ALERT_ILLEGAL_PARAMETER
    desc:
      - Send illegal_parameter alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECODE_ERROR
    desc:
      - Send decode_error alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_BAD_CERTIFICATE
    desc:
      - Send bad_certificate alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_UNEXPECTED_MESSAGE
    desc:
      - Send unexpected_message alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_DECRYPT_ERROR
    desc:
      - Send decrypt_error alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_PROTOCOL_VERSION
    desc:
      - Send protocol_version alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_MISSING_EXTENSION
    desc:
      - Send missing_extension alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: SEND_ALERT_UNSUPPORTED_CERTIFICATE
    desc:
      - Send unsupported_certificate alert
    channels:
      - name: record_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED

  - name: CONNECTION_TERMINATED
    desc:
      - Inform client application
    channels:
      - name: application_out
        access: w
    transitions:
      - target: FINAL

  - name: INVALID_CONFIGURATION
    desc:
      - Inform client application
    channels:
      - name: application_out
        access: w
    transitions:
      - target: CONNECTION_TERMINATED
