with TLS_Alert;
with TLS_Handshake;

package GreenTLS is

   type KM_Length is range 0 .. 16320 with Size => 16;

   type Content is
      message
         null
            then Data
               with Length => Message'Length;
         Data : Payload;
      end message;

   type Control_Message_Type is (KEY_UPDATE_CLIENT, KEY_UPDATE_SERVER, HEARTBEAT_MODE, ALERT) with Size => 8;
   type Control_Message_Length is range 0 .. 2**16 - 1 with Size => 16;

   type Control_Message is
      message
         Tag : Control_Message_Type;
         Length : Control_Message_Length
            then Payload
               with Length => Length;
         Data : Payload;
      end message;

   type Key_Length is range 8 .. 64 with Size => 8;

   type Key_Update_Message is
      message
         Key_Length : Key_Length
            then Key
               with Length => Key_Length * 8;
         Key : Payload;
         IV_Length : Key_Length
            then IV
               with Length => IV_Length;
         IV : Payload;
      end message;

   for Control_Message use (Data => Key_Update_Message)
      if Tag = KEY_UPDATE_CLIENT or Tag = KEY_UDPATE_SERVER;

   type Heartbeat_Mode is (HEARTBEAT_ENABLED, HEARTBEAT_DISABLED) with Size => 4;

   type Heartbeat_Control_Message is
      message
         Local : Heartbeat_Mode;
         Remote : TLS_Handshake.Heartbeat_Mode;
      end message;

   for Control_Message use (Data => Heartbeat_Control_Message)
      if Tag = HEARTBEAT_MODE;

   type Alert_Message is
      message
         Description : TLS_Alert.Alert_Description;
      end message;

   for Control_Message use (Data => Alert_Message)
      if Tag = ALERT;

   type Application_Control_Message_Type is (APPLICATION_SHUTDOWN, APPLICATION_ALERT, APPLICATION_PROTOCOL, APPLICATION_NO_EARLY_DATA) with Size => 8;

   type Application_Control_Message_Length is range 0 .. 2**8 - 1 with Size => 8;

   type Application_Control_Message is
      message
         Tag : Application_Control_Message_Type;
         Length : Length;
         Data : Payload;
      end message;

   type Application_Shutdown_Message is null message;

   for Application_Control_Message use (Data => Application_Shutdown_Message)
      if Tag = APPLICATION_SHUTDOWN;

   for Application_Control_Message use (Data => Alert_Message)
      if Tag = APPLICATION_ALERT;

   type Application_Protocol_Message is
      message
         Protocol : TLS_Handshake.Protocol_Name;
      end message;

   for Application_Control_Message use (Data => Application_Protocol_Message)
      if Tag = APPLICATION_PROTOCOL;

   type Application_No_Early_Data_Message is null message;

   for Application_Control_Message use (Data => Application_No_Early_Data_Message)
      if Tag = APPLICATION_NO_EARLY_DATA;

   type Heartbeat_Data_Length is range 0 .. 2**14 with Size => 16;

   type Heartbeat_Data_Message is
      message
         Length : Heartbeat_Data_Length
            then Data
               with Length => Length;
         Data : Payload;
      end message;

   type Configuration is
      message
         PSK_Key_Exchange_Modes_Length : TLS_Handshake.PSK_Key_Exchange_Modes_Length
            then PSK_Key_Exchange_Modes
               with Length => PSK_Key_Exchange_Modes_Length;
         PSK_Key_Exchange_Modes : TLS_Handshake.Key_Exchange_Modes;  -- FIXME: must only contain PSK_KE and/or PSK_DHE_KE
         Cipher_Suites_Length : TLS_Handshake.Cipher_Suites_Length
            then Cipher_Suites
               with Length => Cipher_Suites_Length * 8;
         Cipher_Suites : TLS_Handshake.Cipher_Suites;
         -- FIXME: use SupportedGroups message as field type?
         Supported_Groups_Length : Supported_Groups_Length
            then Groups
               with Length => Supported_Groups_Length;
         Supported_Groups : Named_Groups;
         Signature_Algorithms_Length : TLS_Handshake.Signature_Algorithms_Length
            then Signature_Algorithms
               with Length => Signature_Algorithms_Length;
         Signature_Algorithms : TLS_Handshake.Signature_Schemes;
         Signature_Algorithms_Cert_Enabled : Boolean
            then Signature_Algorithms_Length_Cert
               if Signature_Algorithms_Cert_Enabled = True,
            then Key_Shares_Length
               if Signature_Algorithms_Cert_Enabled = False;
         Signature_Algorithms_Length_Cert : TLS_Handshake.Signature_Algorithms_Length
            then Signature_Algorithms_Length_Cert
               with Length => Signature_Algorithms_Length_Cert;
         Signature_Algorithms_Cert : TLS_Handshake.Signature_Schemes;
         Key_Shares_Length : TLS_Handshake.Key_Shares_Length
            then Key_Shares
               with Length => Key_Shares_Length;
         Key_Shares : TLS_Handshake.Key_Share_Entries;
         Protocols_Length : TLS_Handshake.Protocols_Length
            then Protocols
               with Length => Protocols_Length;
         Protocols : TLS_Handshake.Protocol_Names;
         Server_Authentication_Enabled : Boolean;
         Post_Handshake_Auth_Enabled : Boolean;
         Early_Data_Enabled : Boolean;
         Server_Name_Enabled : Boolean;
         Max_Fragment_Length_Enabled : Boolean;
         Max_Fragment_Length : TLS_Handshake.Max_Fragment_Length_Value;
         Heartbeat_Mode : Heartbeat_Mode;
      end message;

   type Name_Length is 1 .. 253 with Size => 8;
   type Port is range 1 .. 65535 with Size => 16;

   type Connection is
      message
         Name_Length : Name_Length
            then Name
               with Length = Name_Length;
         Name : Payload;
         Port : Port;
      end message;

   type Keystore_Message_Type is (KEYSTORE_REQUEST, KEYSTORE_RESPONSE) with Size => 8;
   type Keystore_Request_Type is (KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS, KEYSTORE_REQUEST_PSKS) with Size => 8;
   type Keystore_Payload_Length is range 0 .. 2**16 - 1 with Size => 16;

   type Keystore_Message is
      message
         Tag : Keystore_Message_Type
         Request : Keystore_Request_Type;
         Length : Keystore_Payload_Length;
         Payload : Payload;
      end message;

   for Keystore_Message use (Payload => Connection)
      if Tag = KEYSTORE_REQUEST and Request = KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS;

   for Keystore_Message use (Payload => TLS_Handshake.Supported_Groups)
      if Tag = KEYSTORE_RESPONSE and Request = KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS;

   for Keystore_Message use (Payload => Connection)
      if Tag = KEYSTORE_REQUEST and Request = KEYSTORE_REQUEST_PSKS;

   type Key_Type is (EXTERNAL, RESUMPTION) with Size => 8;

   type PSK is
      message
         Identity_Length : Length
            then Identity
               with Length => Identity_Length;
         Identity : TLS_Handshake.PSK_Identity;
         Cipher_Suite : TLS_Handshake.Cipher_Suite;
         Key_Type : Key_Type;
         Key_Length : Key_Length
            then Key
               with Length => Key_Length;
         Key : Payload;
      end message;

   type PSKs is array PSK;

   type PSK_Message is
      message
         null
            then PSKs
               with Length => Message'Length;
         PSKs : PSKs;
      end message;

   for Keystore_Message use (Payload => PSK_Message)
      if Tag = KEYSTORE_RESPONSE and Request = KEYSTORE_REQUEST_PSKS;

end GreenTLS;
